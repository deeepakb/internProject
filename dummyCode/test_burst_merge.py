# Copyright 2022 Amazon.com, Inc. or its affiliates
# All Rights Reserved
import pytest
import uuid

from raff.burst.burst_super_simulated_mode_helper import super_simulated_mode
from raff.common.dimensions import Dimensions
from raff.burst.burst_temp_write import burst_user_temp_support_gucs
from raff.burst.burst_write import BurstWriteTest

__all__ = [super_simulated_mode]

SNAPSHOT_IDENTIFIER = "burst-{}".format(str(uuid.uuid4().hex))
CREATE_SCHEMA = """CREATE EXTERNAL SCHEMA IF NOT EXISTS s3_merge_test
                    FROM DATA CATALOG DATABASE 'default' REGION 'us-west-2'
                    IAM_ROLE 'arn:aws:iam::467896856988:role/Redshift-S3'"""
GRANT_SCHEMA = """Grant usage on schema s3_merge_test to public"""


@pytest.mark.ssm_perm_or_temp_config
@pytest.mark.serial_only
@pytest.mark.localhost_only
@pytest.mark.skip_load_data
@pytest.mark.super_simulated_mode
@pytest.mark.backup_and_cold_start(backup_id=SNAPSHOT_IDENTIFIER)
@pytest.mark.custom_local_gucs(gucs=dict(
    list(burst_user_temp_support_gucs.items()) +
    [('enable_merge', 'true'), ('enable_simplified_merge_syntax', 'true'),
     ('enable_burst_merge', 'true'), ('enable_merge_with_single_when',
                                      'true')]))
@pytest.mark.custom_burst_gucs(gucs=burst_user_temp_support_gucs)
@pytest.mark.usefixtures("super_simulated_mode")
class TestBurstMergeStatementEnabled(BurstWriteTest):

    @classmethod
    def modify_test_dimensions(cls):
        return Dimensions(dict(in_txn=[True, False]))

    '''Test MERGE statement with burst write.'''

    def test_burst_merge_stmt_enabled(self, cluster, db_session, is_temp,
                                      vector):
        try:
            with db_session.cursor() as cursor:
                cursor.execute(
                    "CREATE {} TABLE IF NOT EXISTS t1 (a int, b int) "
                    "diststyle even".format('TEMP' if is_temp else ''))
                cursor.execute(
                    "CREATE {} TABLE IF NOT EXISTS s1 (a int, b int) "
                    "diststyle even".format('TEMP' if is_temp else ''))
                if vector.in_txn:
                    cursor.execute("BEGIN")
                    if not is_temp:
                        self._start_and_wait_for_refresh(cluster)
                cursor.execute("set query_group to burst")
                cursor.execute("INSERT INTO t1 VALUES (1, 100), (2, 200)")
                cursor.execute("INSERT INTO s1 VALUES (3, 300), (2, 222)")
                if not vector.in_txn and not is_temp:
                    self._start_and_wait_for_refresh(cluster)
                cursor.execute("MERGE INTO t1 USING s1 ON t1.a = s1.a "
                               "REMOVE DUPLICATES")
                if vector.in_txn:
                    cursor.execute("COMMIT")
                cursor.execute(
                    "select concurrency_scaling_status from stl_query "
                    "where xid in (select xid from stl_query "
                    "where query = pg_last_query_id()) order by query")
                # This MERGE query is rewritten into DELETE and INSERT. Both
                # queries should burst.
                if vector.in_txn:
                    # xid of last query comes from merge which was in txn
                    # with two insert queries running on burst. So the four
                    # queries expected to have bursted are two INSERT queries
                    # MERGE and DELETE which was generated by the MERGE.
                    assert cursor.fetchall() == [(1, ), (1, ), (1, ), (1, )]
                else:
                    # Outside of txn last query xid was just the MERGE query.
                    # MERGE also generated a DELETE query.
                    assert cursor.fetchall() == [(1, ), (1, )]
                # Check the target table.
                cursor.execute("select * from t1 order by 1,2")
                assert cursor.fetchall() == [(1, 100), (2, 222), (3, 300)]

                # Test MERGE containing DELETE.
                if vector.in_txn:
                    cursor.execute("BEGIN")
                    if not is_temp:
                        self._start_and_wait_for_refresh(cluster)
                cursor.execute("set query_group to burst")
                cursor.execute("INSERT INTO s1 VALUES (4, 400)")
                if not vector.in_txn and not is_temp:
                    self._start_and_wait_for_refresh(cluster)
                cursor.execute(
                    "MERGE INTO t1 USING s1 ON t1.a = s1.a "
                    "WHEN matched THEN DELETE "
                    "WHEN NOT matched THEN INSERT VALUES (s1.a, s1.b)")
                if vector.in_txn:
                    cursor.execute("COMMIT")
                cursor.execute(
                    "select concurrency_scaling_status from stl_query "
                    "where xid in (select xid from stl_query "
                    "where query = pg_last_query_id()) order by query")
                # This MERGE query is rewritten into CTAS, DELETE and INSERT with
                # temp table.
                if vector.in_txn:
                    # INSERT bursts in same txn as MERGE.
                    assert cursor.fetchall() == [(1, ), (1, ), (1, ), (1, )]
                else:
                    assert cursor.fetchall() == [(1, ), (1, ), (1, )]
                # Check the target table.
                cursor.execute("select * from t1 order by 1,2")
                assert cursor.fetchall() == [(1, 100), (4, 400)]

                # Test Merge query is bursted as expected in stored procedure.
                cursor.execute(
                    "CREATE PROCEDURE merge_sp() AS $$ BEGIN "
                    "MERGE INTO t1 USING s1 ON t1.a = s1.a "
                    "WHEN matched THEN UPDATE set a = s1.a, b = s1.b "
                    "WHEN NOT matched THEN INSERT VALUES (s1.a, s1.b); "
                    "END; $$ LANGUAGE plpgsql")
                self._start_and_wait_for_refresh(cluster)
                cursor.execute("set query_group to burst")
                cursor.execute("CALL merge_sp()")
                cursor.execute(
                    "select concurrency_scaling_status from stl_query "
                    "where xid in (select xid from stl_query "
                    "where query = pg_last_query_id()) order by query")
                # This MERGE query is rewritten into CTAS, UPDATE and INSERT with
                # temp table.
                assert cursor.fetchall() == [(1, ), (1, ), (1, )]
                # Check the target table.
                cursor.execute("select * from t1 order by 1,2")
                assert cursor.fetchall() == [(1, 100), (2, 222), (3, 300),
                                             (4, 400)]

                # Test MERGE with single WHEN clause containing UPDATE.
                if vector.in_txn:
                    cursor.execute("BEGIN")
                    if not is_temp:
                        self._start_and_wait_for_refresh(cluster)
                cursor.execute("set query_group to burst")
                cursor.execute("DELETE FROM t1")
                cursor.execute("INSERT INTO t1 VALUES (1, 100), (2, 200)")
                if not vector.in_txn and not is_temp:
                    self._start_and_wait_for_refresh(cluster)
                cursor.execute(
                    "MERGE INTO t1 USING s1 ON t1.a = s1.a "
                    "WHEN matched THEN UPDATE SET a = s1.a, b = s1.b")
                if vector.in_txn:
                    cursor.execute("COMMIT")
                cursor.execute(
                    "select concurrency_scaling_status from stl_query "
                    "where xid in (select xid from stl_query "
                    "where query = pg_last_query_id()) order by query")
                # This MERGE query is rewritten into UPDATE.
                if vector.in_txn:
                    # DELETE, INSERT bursts in same txn as MERGE.
                    assert cursor.fetchall() == [(1, ), (1, ), (1, )]
                else:
                    assert cursor.fetchall() == [(1, )]
                # Check the target table.
                cursor.execute("select * from t1 order by 1,2")
                assert cursor.fetchall() == [(1, 100), (2, 222)]

                # Test MERGE with single WHEN clause containing DELETE.
                if vector.in_txn:
                    cursor.execute("BEGIN")
                    if not is_temp:
                        self._start_and_wait_for_refresh(cluster)
                cursor.execute("set query_group to burst")
                cursor.execute("DELETE FROM t1")
                cursor.execute("INSERT INTO t1 VALUES (1, 100), (2, 200)")
                if not vector.in_txn and not is_temp:
                    self._start_and_wait_for_refresh(cluster)
                cursor.execute("MERGE INTO t1 USING s1 ON t1.a = s1.a "
                               "WHEN matched THEN DELETE")
                if vector.in_txn:
                    cursor.execute("COMMIT")
                cursor.execute(
                    "select concurrency_scaling_status from stl_query "
                    "where xid in (select xid from stl_query "
                    "where query = pg_last_query_id()) order by query")
                # This MERGE query is rewritten into DELETE.
                if vector.in_txn:
                    # DELETE, INSERT bursts in same txn as MERGE.
                    assert cursor.fetchall() == [(1, ), (1, ), (1, )]
                else:
                    assert cursor.fetchall() == [(1, )]
                # Check the target table.
                cursor.execute("select * from t1 order by 1,2")
                assert cursor.fetchall() == [(1, 100)]

                # Test MERGE with single WHEN clause containing INSERT.
                if vector.in_txn:
                    cursor.execute("BEGIN")
                    if not is_temp:
                        self._start_and_wait_for_refresh(cluster)
                cursor.execute("set query_group to burst")
                cursor.execute("DELETE FROM t1")
                cursor.execute("INSERT INTO t1 VALUES (1, 100), (2, 200)")
                if not vector.in_txn and not is_temp:
                    self._start_and_wait_for_refresh(cluster)
                cursor.execute(
                    "MERGE INTO t1 USING s1 ON t1.a = s1.a "
                    "WHEN NOT matched THEN INSERT VALUES (s1.a, s1.b)")
                if vector.in_txn:
                    cursor.execute("COMMIT")
                cursor.execute(
                    "select concurrency_scaling_status from stl_query "
                    "where xid in (select xid from stl_query "
                    "where query = pg_last_query_id()) order by query")
                # This MERGE query is rewritten into INSERT.
                if vector.in_txn:
                    # DELETE, INSERT bursts in same txn as MERGE.
                    assert cursor.fetchall() == [(1, ), (1, ), (1, )]
                else:
                    assert cursor.fetchall() == [(1, )]
                # Check the target table.
                cursor.execute("select * from t1 order by 1,2")
                assert cursor.fetchall() == [(1, 100), (2, 200), (3, 300),
                                             (4, 400)]

                # Test Merge query with single WHEN clause for UPDATE
                # is bursted as expected in stored procedure.
                cursor.execute("DELETE FROM t1")
                cursor.execute("INSERT INTO t1 VALUES (1, 100), (2, 200)")
                cursor.execute(
                    "CREATE PROCEDURE merge_sp1() AS $$ BEGIN "
                    "MERGE INTO t1 USING s1 ON t1.a = s1.a "
                    "WHEN matched THEN UPDATE SET a = s1.a, b = s1.b; "
                    "END; $$ LANGUAGE plpgsql")
                self._start_and_wait_for_refresh(cluster)
                cursor.execute("set query_group to burst")
                cursor.execute("CALL merge_sp1()")
                cursor.execute(
                    "select concurrency_scaling_status from stl_query "
                    "where xid in (select xid from stl_query "
                    "where query = pg_last_query_id()) order by query")
                # This MERGE query is rewritten into DELETE.
                assert cursor.fetchall() == [(1, )]
                # Check the target table.
                cursor.execute("select * from t1 order by 1,2")
                assert cursor.fetchall() == [(1, 100), (2, 222)]

                # Test Merge query with single WHEN clause for DELETE
                # is bursted as expected in stored procedure.
                cursor.execute("DELETE FROM t1")
                cursor.execute("INSERT INTO t1 VALUES (1, 100), (2, 200)")
                cursor.execute("CREATE PROCEDURE merge_sp2() AS $$ BEGIN "
                               "MERGE INTO t1 USING s1 ON t1.a = s1.a "
                               "WHEN matched THEN DELETE; "
                               "END; $$ LANGUAGE plpgsql")
                self._start_and_wait_for_refresh(cluster)
                cursor.execute("set query_group to burst")
                cursor.execute("CALL merge_sp2()")
                cursor.execute(
                    "select concurrency_scaling_status from stl_query "
                    "where xid in (select xid from stl_query "
                    "where query = pg_last_query_id()) order by query")
                # This MERGE query is rewritten into DELETE.
                assert cursor.fetchall() == [(1, )]
                # Check the target table.
                cursor.execute("select * from t1 order by 1,2")
                assert cursor.fetchall() == [(1, 100)]

                # Test Merge query with single WHEN clause for INSERT
                # is bursted as expected in stored procedure.
                cursor.execute("DELETE FROM t1")
                cursor.execute("INSERT INTO t1 VALUES (1, 100), (2, 200)")
                cursor.execute(
                    "CREATE PROCEDURE merge_sp3() AS $$ BEGIN "
                    "MERGE INTO t1 USING s1 ON t1.a = s1.a "
                    "WHEN NOT matched THEN INSERT VALUES (s1.a, s1.b); "
                    "END; $$ LANGUAGE plpgsql")
                self._start_and_wait_for_refresh(cluster)
                cursor.execute("set query_group to burst")
                cursor.execute("CALL merge_sp3()")
                cursor.execute(
                    "select concurrency_scaling_status from stl_query "
                    "where xid in (select xid from stl_query "
                    "where query = pg_last_query_id()) order by query")
                # This MERGE query is rewritten into INSERT.
                assert cursor.fetchall() == [(1, )]
                # Check the target table.
                cursor.execute("select * from t1 order by 1,2")
                assert cursor.fetchall() == [(1, 100), (2, 200), (3, 300),
                                             (4, 400)]

                # Test Merge busrt in stored procedure with external table as source.
                cursor.execute(CREATE_SCHEMA)
                cursor.execute(GRANT_SCHEMA)
                cursor.execute("DROP TABLE IF EXISTS target_e cascade")
                cursor.execute(
                    "CREATE {} TABLE IF NOT EXISTS "
                    "target_e (cint bigint, cvarchar varchar(30)) "
                    "diststyle even".format('TEMP' if is_temp else ''))

                # Test MERGE with SP for single WHEN clause UPDATE with external table.
                cursor.execute("""
                    CREATE PROCEDURE merge_sp4(f1 bigint)
                    AS $$
                    BEGIN
                        INSERT INTO target_e VALUES (8, 'abc'), (100, 'Redshift');
                        MERGE INTO target_e USING s3_merge_test.alltypes_csv AS s
                        ON target_e.cint = s.cint
                        WHEN matched THEN
                        UPDATE SET cint = s.cint + f1, cvarchar = s.cvarchar;
                    END;
                    $$ LANGUAGE PLPGSQL;
                """)
                self._start_and_wait_for_refresh(cluster)
                cursor.execute("SET query_group TO burst")
                cursor.execute("CALL merge_sp4(1)")
                cursor.execute(
                    "select concurrency_scaling_status from stl_query "
                    "where xid in (select xid from stl_query "
                    "where query = pg_last_query_id()) order by query")
                # This MERGE query is rewritten into UPDATE.
                assert cursor.fetchall() == [(1, ), (1, )]
                # Check the target table.
                cursor.execute("SELECT * FROM target_e ORDER BY 1,2")
                assert cursor.fetchall() == [(9, 'Meng'), (100, 'Redshift')]

                # Test MERGE with SP for single WHEN clause INSERT with external table.
                cursor.execute("DELETE FROM target_e")
                cursor.execute("""
                    CREATE PROCEDURE merge_sp5(f1 bigint, f2 varchar(10))
                    AS $$
                    BEGIN
                        INSERT INTO target_e VALUES (8, 'abc'), (100, 'Redshift');
                        MERGE INTO target_e USING s3_merge_test.alltypes_csv AS s
                        ON target_e.cint = s.cint
                        WHEN NOT matched THEN
                        INSERT VALUES (s.cint + f1, s.cvarchar + f2);
                    END;
                    $$ LANGUAGE PLPGSQL;
                """)
                self._start_and_wait_for_refresh(cluster)
                cursor.execute("SET query_group TO burst")
                cursor.execute("CALL merge_sp5(1, '-aws')")
                cursor.execute(
                    "select concurrency_scaling_status from stl_query "
                    "where xid in (select xid from stl_query "
                    "where query = pg_last_query_id()) order by query")
                # This MERGE query is rewritten into INSERT.
                assert cursor.fetchall() == [(1, ), (1, )]
                # Check the target table.
                cursor.execute("SELECT * FROM target_e ORDER BY 1,2")
                assert cursor.fetchall() == [(-2147483644, "Fabian-aws"),
                                             (-2147483644, "Jenny-aws"),
                                             (-2147483644, "Yannis-aws"),
                                             (0, "Meng-aws"),
                                             (1, "Martin-aws"),
                                             (2, "Mengchu-aws"),
                                             (3, "Anurag-aws"),
                                             (4, "Vidhya-aws"),
                                             (5, "Michalis-aws"),
                                             (6, "Ippokratis-aws"),
                                             (7, "Mengchu-aws"),
                                             (8, "Martin-aws"), (8, "abc"),
                                             (10, "Fabian-aws"),
                                             (11, "Jenny-aws"),
                                             (12, "Yannis-aws"),
                                             (13, "Dory-aws"),
                                             (14, "Anurag-aws"),
                                             (100, "Redshift"),
                                             (2147483641, "Ippokratis-aws"),
                                             (2147483641, "Michalis-aws"),
                                             (2147483641, "Vidhya-aws")]
                # Test MERGE with SP for single WHEN clause DELETE with external table.
                cursor.execute("DELETE FROM target_e")
                cursor.execute("""
                    CREATE PROCEDURE merge_sp6(f1 bigint)
                    AS $$
                    BEGIN
                        INSERT INTO target_e VALUES (8, 'abc'), (100, 'Redshift');
                        MERGE INTO target_e USING s3_merge_test.alltypes_csv AS s
                        ON target_e.cint + f1 = s.cint + f1
                        WHEN matched THEN DELETE;
                    END;
                    $$ LANGUAGE PLPGSQL;
                """)
                self._start_and_wait_for_refresh(cluster)
                cursor.execute("SET query_group TO burst")
                cursor.execute("CALL merge_sp6(100)")
                cursor.execute(
                    "select concurrency_scaling_status from stl_query "
                    "where xid in (select xid from stl_query "
                    "where query = pg_last_query_id()) order by query")
                # This MERGE query is rewritten into DELETE.
                assert cursor.fetchall() == [(1, ), (1, )]
                # Check the target table.
                cursor.execute("SELECT * FROM target_e ORDER BY 1,2")
                assert cursor.fetchall() == [(100, 'Redshift')]

                # Test MERGE with SP for single WHEN clause UPDATE
                # with subquery from external table as source.
                cursor.execute("DELETE FROM target_e")
                cursor.execute("""
                    CREATE PROCEDURE merge_sp10(f1 bigint)
                    AS $$
                    BEGIN
                        INSERT INTO target_e VALUES (8, 'abc'), (100, 'Redshift');
                        MERGE INTO target_e USING
                        (SELECT * FROM s3_merge_test.alltypes_csv) AS s
                        ON target_e.cint = s.cint
                        WHEN matched THEN
                        UPDATE SET cint = s.cint + f1, cvarchar = s.cvarchar;
                    END;
                    $$ LANGUAGE PLPGSQL;
                """)
                self._start_and_wait_for_refresh(cluster)
                cursor.execute("SET query_group TO burst")
                cursor.execute("CALL merge_sp10(1)")
                cursor.execute(
                    "select concurrency_scaling_status from stl_query "
                    "where xid in (select xid from stl_query "
                    "where query = pg_last_query_id()) order by query")
                # This MERGE query is rewritten into UPDATE.
                assert cursor.fetchall() == [(1, ), (1, )]
                # Check the target table.
                cursor.execute("SELECT * FROM target_e ORDER BY 1,2")
                assert cursor.fetchall() == [(9, 'Meng'), (100, 'Redshift')]

                # Test MERGE with SP for single WHEN clause INSERT
                # with subquery from external table as source.
                cursor.execute("DELETE FROM target_e")
                cursor.execute("""
                    CREATE PROCEDURE merge_sp11(f1 bigint, f2 varchar(10))
                    AS $$
                    BEGIN
                        INSERT INTO target_e VALUES (8, 'abc'), (100, 'Redshift');
                        MERGE INTO target_e USING
                        (SELECT * FROM s3_merge_test.alltypes_csv) AS s
                        ON target_e.cint = s.cint
                        WHEN NOT matched THEN
                        INSERT VALUES (s.cint + f1, s.cvarchar + f2);
                    END;
                    $$ LANGUAGE PLPGSQL;
                """)
                self._start_and_wait_for_refresh(cluster)
                cursor.execute("SET query_group TO burst")
                cursor.execute("CALL merge_sp11(1, '-aws')")
                cursor.execute(
                    "select concurrency_scaling_status from stl_query "
                    "where xid in (select xid from stl_query "
                    "where query = pg_last_query_id()) order by query")
                # This MERGE query is rewritten into INSERT.
                assert cursor.fetchall() == [(1, ), (1, )]
                # Check the target table.
                cursor.execute("SELECT * FROM target_e ORDER BY 1,2")
                assert cursor.fetchall() == [(-2147483644, "Fabian-aws"),
                                             (-2147483644, "Jenny-aws"),
                                             (-2147483644, "Yannis-aws"),
                                             (0, "Meng-aws"),
                                             (1, "Martin-aws"),
                                             (2, "Mengchu-aws"),
                                             (3, "Anurag-aws"),
                                             (4, "Vidhya-aws"),
                                             (5, "Michalis-aws"),
                                             (6, "Ippokratis-aws"),
                                             (7, "Mengchu-aws"),
                                             (8, "Martin-aws"), (8, "abc"),
                                             (10, "Fabian-aws"),
                                             (11, "Jenny-aws"),
                                             (12, "Yannis-aws"),
                                             (13, "Dory-aws"),
                                             (14, "Anurag-aws"),
                                             (100, "Redshift"),
                                             (2147483641, "Ippokratis-aws"),
                                             (2147483641, "Michalis-aws"),
                                             (2147483641, "Vidhya-aws")]
                # Test MERGE with SP for single WHEN clause DELETE
                # with subquery from external table as source.
                cursor.execute("DELETE FROM target_e")
                cursor.execute("""
                    CREATE PROCEDURE merge_sp12(f1 bigint)
                    AS $$
                    BEGIN
                        INSERT INTO target_e VALUES (8, 'abc'), (100, 'Redshift');
                        MERGE INTO target_e USING
                        (SELECT * FROM s3_merge_test.alltypes_csv) AS s
                        ON target_e.cint + f1 = s.cint + f1
                        WHEN matched THEN DELETE;
                    END;
                    $$ LANGUAGE PLPGSQL;
                """)
                self._start_and_wait_for_refresh(cluster)
                cursor.execute("SET query_group TO burst")
                cursor.execute("CALL merge_sp12(100)")
                cursor.execute(
                    "select concurrency_scaling_status from stl_query "
                    "where xid in (select xid from stl_query "
                    "where query = pg_last_query_id()) order by query")
                # This MERGE query is rewritten into DELETE.
                assert cursor.fetchall() == [(1, ), (1, )]
                # Check the target table.
                cursor.execute("SELECT * FROM target_e ORDER BY 1,2")
                assert cursor.fetchall() == [(100, 'Redshift')]
        finally:
            with db_session.cursor() as cursor:
                # Clean up.
                cursor.execute("DROP PROCEDURE merge_sp()")
                cursor.execute("DROP PROCEDURE merge_sp1()")
                cursor.execute("DROP PROCEDURE merge_sp2()")
                cursor.execute("DROP PROCEDURE merge_sp3()")
                cursor.execute("DROP PROCEDURE merge_sp4(f1 bigint)")
                cursor.execute(
                    "DROP PROCEDURE merge_sp5(f1 bigint, f2 varchar(10))")
                cursor.execute("DROP PROCEDURE merge_sp6(f1 bigint)")
                cursor.execute("DROP PROCEDURE merge_sp10(f1 bigint)")
                cursor.execute(
                    "DROP PROCEDURE merge_sp11(f1 bigint, f2 varchar(10))")
                cursor.execute("DROP PROCEDURE merge_sp12(f1 bigint)")
                cursor.execute("DROP TABLE IF EXISTS t1")
                cursor.execute("DROP TABLE IF EXISTS s1")
                cursor.execute("DROP TABLE IF EXISTS target_e")


@pytest.mark.ssm_perm_or_temp_config
@pytest.mark.serial_only
@pytest.mark.localhost_only
@pytest.mark.skip_load_data
@pytest.mark.super_simulated_mode
@pytest.mark.backup_and_cold_start(backup_id=SNAPSHOT_IDENTIFIER)
@pytest.mark.custom_local_gucs(gucs=dict(
    list(burst_user_temp_support_gucs.items()) +
    [('enable_merge', 'true'), ('enable_simplified_merge_syntax', 'true'),
     ('enable_burst_merge', 'false'), ('enable_merge_with_single_when',
                                       'true')]))
@pytest.mark.custom_burst_gucs(gucs=burst_user_temp_support_gucs)
@pytest.mark.usefixtures("super_simulated_mode")
class TestBurstMergeStatementDisabled(BurstWriteTest):

    @classmethod
    def modify_test_dimensions(cls):
        return Dimensions(dict(in_txn=[True, False]))

    '''Test MERGE statement with burst write.'''

    def test_burst_merge_stmt_disabled(self, cluster, db_session, is_temp,
                                       vector):
        try:
            with db_session.cursor() as cursor, self.db.cursor() as db_cursor:
                cursor.execute(
                    "CREATE {} TABLE IF NOT EXISTS t1 (a int, b int) "
                    "diststyle even".format('TEMP' if is_temp else ''))
                cursor.execute(
                    "CREATE {} TABLE IF NOT EXISTS s1 (a int, b int) "
                    "diststyle even".format('TEMP' if is_temp else ''))
                if vector.in_txn:
                    cursor.execute("BEGIN")
                    if not is_temp:
                        self._start_and_wait_for_refresh(cluster)
                cursor.execute("set query_group to burst")
                cursor.execute("INSERT INTO t1 VALUES (1, 100), (2, 200)")
                cursor.execute("INSERT INTO s1 VALUES (3, 300), (2, 222)")
                if not vector.in_txn and not is_temp:
                    self._start_and_wait_for_refresh(cluster)
                cursor.execute(
                    "MERGE INTO t1 USING s1 ON t1.a = s1.a "
                    "WHEN matched THEN UPDATE set a = s1.a, b = s1.b "
                    "WHEN NOT matched THEN INSERT VALUES (s1.a, s1.b)")
                if vector.in_txn:
                    cursor.execute("COMMIT")
                # Get xid.
                cursor.execute("select xid from stl_query where "
                               "query = pg_last_query_id()")
                xid = cursor.fetch_scalar()
                cursor.execute(
                    "select concurrency_scaling_status from stl_query "
                    "where xid = {} order by query".format(xid))
                # Burst MERGE query is disabled and burst state code is 72.
                if vector.in_txn:
                    # Insert bursts in same txn as MERGE.
                    assert cursor.fetchall() == [(1, ), (1, ), (72, ), (72, ),
                                                 (72, )]
                else:
                    # Insert not included in same txn as MERGE.
                    assert cursor.fetchall() == [(72, ), (72, ), (72, )]
                # Check burst status text.
                db_cursor.execute("select concurrency_scaling_status_txt from "
                                  "svl_query_concurrency_scaling_status "
                                  "where xid = {} order by query".format(xid))

                if vector.in_txn:
                    assert db_cursor.fetchall() == [
                        ('Ran on a Concurrency Scaling cluster', ),
                        ('Ran on a Concurrency Scaling cluster', ),
                        ('Concurrency Scaling ineligible query '
                         '- Burst MERGE is disabled', ),
                        ('Concurrency Scaling ineligible query '
                         '- Burst MERGE is disabled', ),
                        ('Concurrency Scaling ineligible query '
                         '- Burst MERGE is disabled', )
                    ]
                else:
                    assert db_cursor.fetchall() == [
                        ('Concurrency Scaling ineligible query '
                         '- Burst MERGE is disabled', ),
                        ('Concurrency Scaling ineligible query '
                         '- Burst MERGE is disabled', ),
                        ('Concurrency Scaling ineligible query '
                         '- Burst MERGE is disabled', )
                    ]

                # Check the target table.
                cursor.execute("select * from t1 order by 1,2")
                assert cursor.fetchall() == [(1, 100), (2, 222), (3, 300)]

                # Test MERGE containing DELETE.
                if not is_temp:
                    self._start_and_wait_for_refresh(cluster)
                if vector.in_txn:
                    cursor.execute("BEGIN")
                cursor.execute("set query_group to burst")
                cursor.execute("INSERT INTO s1 VALUES (4, 400)")
                if not vector.in_txn and not is_temp:
                    self._start_and_wait_for_refresh(cluster)
                cursor.execute(
                    "MERGE INTO t1 USING s1 ON t1.a = s1.a "
                    "WHEN matched THEN DELETE "
                    "WHEN NOT matched THEN INSERT VALUES (s1.a, s1.b)")
                if vector.in_txn:
                    cursor.execute("COMMIT")
                cursor.execute(
                    "select concurrency_scaling_status from stl_query "
                    "where xid in (select xid from stl_query "
                    "where query = pg_last_query_id()) order by query")
                # Burst MERGE query is disabled and burst state code is 72.
                if vector.in_txn:
                    # INSERT will burst in the same txn as MERGE.
                    assert cursor.fetchall() == [(1, ), (72, ), (72, ), (72, )]
                else:
                    # INSERT not in same txn as MERGE.
                    assert cursor.fetchall() == [(72, ), (72, ), (72, )]
                # Check the target table.
                cursor.execute("select * from t1 order by 1,2")
                assert cursor.fetchall() == [(1, 100), (4, 400)]

                # Test MERGE with single WHEN for UPDATE.
                if vector.in_txn:
                    cursor.execute("BEGIN")
                    if not is_temp:
                        self._start_and_wait_for_refresh(cluster)
                cursor.execute("set query_group to burst")
                cursor.execute("DELETE FROM t1")
                cursor.execute("INSERT INTO t1 VALUES (1, 100), (2, 200)")
                if not vector.in_txn and not is_temp:
                    self._start_and_wait_for_refresh(cluster)
                cursor.execute(
                    "MERGE INTO t1 USING s1 ON t1.a = s1.a "
                    "WHEN matched THEN UPDATE set a = s1.a, b = s1.b ")
                if vector.in_txn:
                    cursor.execute("COMMIT")
                # Get xid.
                cursor.execute("select xid from stl_query where "
                               "query = pg_last_query_id()")
                xid = cursor.fetch_scalar()
                cursor.execute(
                    "select concurrency_scaling_status from stl_query "
                    "where xid = {} order by query".format(xid))
                # Burst MERGE query is disabled and burst state code is 72.
                if vector.in_txn:
                    # Delete, Insert bursts in same txn as MERGE.
                    assert cursor.fetchall() == [(1, ), (1, ), (72, )]
                else:
                    # Delete, Insert not included in same txn as MERGE.
                    assert cursor.fetchall() == [(72, )]
                # Check burst status text.
                db_cursor.execute("select concurrency_scaling_status_txt from "
                                  "svl_query_concurrency_scaling_status "
                                  "where xid = {} order by query".format(xid))

                if vector.in_txn:
                    assert db_cursor.fetchall() == [
                        ('Ran on a Concurrency Scaling cluster', ),
                        ('Ran on a Concurrency Scaling cluster', ),
                        ('Concurrency Scaling ineligible query '
                         '- Burst MERGE is disabled', )
                    ]
                else:
                    assert db_cursor.fetchall() == [
                        ('Concurrency Scaling ineligible query '
                         '- Burst MERGE is disabled', )
                    ]

                # Check the target table.
                cursor.execute("select * from t1 order by 1,2")
                assert cursor.fetchall() == [(1, 100), (2, 222)]

                # Test MERGE with single WHEN for DELETE.
                if vector.in_txn:
                    cursor.execute("BEGIN")
                    if not is_temp:
                        self._start_and_wait_for_refresh(cluster)
                cursor.execute("set query_group to burst")
                cursor.execute("DELETE FROM t1")
                cursor.execute("INSERT INTO t1 VALUES (1, 100), (2, 200)")
                if not vector.in_txn and not is_temp:
                    self._start_and_wait_for_refresh(cluster)
                cursor.execute("MERGE INTO t1 USING s1 ON t1.a = s1.a "
                               "WHEN matched THEN DELETE ")
                if vector.in_txn:
                    cursor.execute("COMMIT")
                # Get xid.
                cursor.execute("select xid from stl_query where "
                               "query = pg_last_query_id()")
                xid = cursor.fetch_scalar()
                cursor.execute(
                    "select concurrency_scaling_status from stl_query "
                    "where xid = {} order by query".format(xid))
                # Burst MERGE query is disabled and burst state code is 72.
                if vector.in_txn:
                    # Delete, Insert bursts in same txn as MERGE.
                    assert cursor.fetchall() == [(1, ), (1, ), (72, )]
                else:
                    # Delete, Insert not included in same txn as MERGE.
                    assert cursor.fetchall() == [(72, )]
                # Check burst status text.
                db_cursor.execute("select concurrency_scaling_status_txt from "
                                  "svl_query_concurrency_scaling_status "
                                  "where xid = {} order by query".format(xid))

                if vector.in_txn:
                    assert db_cursor.fetchall() == [
                        ('Ran on a Concurrency Scaling cluster', ),
                        ('Ran on a Concurrency Scaling cluster', ),
                        ('Concurrency Scaling ineligible query '
                         '- Burst MERGE is disabled', )
                    ]
                else:
                    assert db_cursor.fetchall() == [
                        ('Concurrency Scaling ineligible query '
                         '- Burst MERGE is disabled', )
                    ]

                # Check the target table.
                cursor.execute("select * from t1 order by 1,2")
                assert cursor.fetchall() == [(1, 100)]

                # Test MERGE with single WHEN for INSERT.
                if vector.in_txn:
                    cursor.execute("BEGIN")
                    if not is_temp:
                        self._start_and_wait_for_refresh(cluster)
                cursor.execute("set query_group to burst")
                cursor.execute("DELETE FROM t1")
                cursor.execute("INSERT INTO t1 VALUES (1, 100), (2, 200)")
                if not vector.in_txn and not is_temp:
                    self._start_and_wait_for_refresh(cluster)
                cursor.execute(
                    "MERGE INTO t1 USING s1 ON t1.a = s1.a "
                    "WHEN NOT matched THEN INSERT VALUES (s1.a, s1.b) ")
                if vector.in_txn:
                    cursor.execute("COMMIT")
                # Get xid.
                cursor.execute("select xid from stl_query where "
                               "query = pg_last_query_id()")
                xid = cursor.fetch_scalar()
                cursor.execute(
                    "select concurrency_scaling_status from stl_query "
                    "where xid = {} order by query".format(xid))
                # Burst MERGE query is disabled and burst state code is 72.
                if vector.in_txn:
                    # Delete, Insert bursts in same txn as MERGE.
                    assert cursor.fetchall() == [(1, ), (1, ), (72, )]
                else:
                    # Delete, Insert not included in same txn as MERGE.
                    assert cursor.fetchall() == [(72, )]
                # Check burst status text.
                db_cursor.execute("select concurrency_scaling_status_txt from "
                                  "svl_query_concurrency_scaling_status "
                                  "where xid = {} order by query".format(xid))

                if vector.in_txn:
                    assert db_cursor.fetchall() == [
                        ('Ran on a Concurrency Scaling cluster', ),
                        ('Ran on a Concurrency Scaling cluster', ),
                        ('Concurrency Scaling ineligible query '
                         '- Burst MERGE is disabled', )
                    ]
                else:
                    assert db_cursor.fetchall() == [
                        ('Concurrency Scaling ineligible query '
                         '- Burst MERGE is disabled', )
                    ]

                # Check the target table.
                cursor.execute("select * from t1 order by 1,2")
                assert cursor.fetchall() == [(1, 100), (2, 200), (3, 300),
                                             (4, 400)]
                # Test Merge busrt in stored procedure with external table as source.
                cursor.execute(CREATE_SCHEMA)
                cursor.execute(GRANT_SCHEMA)
                cursor.execute("DROP TABLE IF EXISTS target_e cascade")
                cursor.execute(
                    "CREATE {} TABLE IF NOT EXISTS "
                    "target_e (cint bigint, cvarchar varchar(30)) "
                    "diststyle even".format('TEMP' if is_temp else ''))

                # Test MERGE with SP for single WHEN clause UPDATE with external table.
                cursor.execute("""
                    CREATE PROCEDURE merge_sp7(f1 bigint)
                    AS $$
                    BEGIN
                        INSERT INTO target_e VALUES (8, 'abc'), (100, 'Redshift');
                        MERGE INTO target_e USING s3_merge_test.alltypes_csv AS s
                        ON target_e.cint = s.cint
                        WHEN matched THEN UPDATE
                        SET cint = s.cint + f1, cvarchar = s.cvarchar;
                    END;
                    $$ LANGUAGE PLPGSQL;
                """)
                self._start_and_wait_for_refresh(cluster)
                cursor.execute("SET query_group TO burst")
                cursor.execute("CALL merge_sp7(1)")
                cursor.execute(
                    "select concurrency_scaling_status from stl_query "
                    "where xid in (select xid from stl_query "
                    "where query = pg_last_query_id()) order by query")
                # This MERGE query is rewritten into UPDATE.
                assert cursor.fetchall() == [(1, ), (72, )]
                # Check the target table.
                cursor.execute("SELECT * FROM target_e ORDER BY 1,2")
                assert cursor.fetchall() == [(9, 'Meng'), (100, 'Redshift')]

                # Test MERGE with SP for single WHEN clause INSERT with external table.
                cursor.execute("DELETE FROM target_e")
                cursor.execute("""
                    CREATE PROCEDURE merge_sp8(f1 bigint, f2 varchar(10))
                    AS $$
                    BEGIN
                        INSERT INTO target_e VALUES (8, 'abc'), (100, 'Redshift');
                        MERGE INTO target_e USING s3_merge_test.alltypes_csv AS s
                        ON target_e.cint = s.cint
                        WHEN NOT matched THEN
                        INSERT VALUES (s.cint + f1, s.cvarchar + f2);
                    END;
                    $$ LANGUAGE PLPGSQL;
                """)
                self._start_and_wait_for_refresh(cluster)
                cursor.execute("SET query_group TO burst")
                cursor.execute("CALL merge_sp8(1, '-aws')")
                cursor.execute(
                    "select concurrency_scaling_status from stl_query "
                    "where xid in (select xid from stl_query "
                    "where query = pg_last_query_id()) order by query")
                # This MERGE query is rewritten into INSERT.
                assert cursor.fetchall() == [(1, ), (72, )]
                # Check the target table.
                cursor.execute("SELECT * FROM target_e ORDER BY 1,2")
                assert cursor.fetchall() == [(-2147483644, "Fabian-aws"),
                                             (-2147483644, "Jenny-aws"),
                                             (-2147483644, "Yannis-aws"),
                                             (0, "Meng-aws"),
                                             (1, "Martin-aws"),
                                             (2, "Mengchu-aws"),
                                             (3, "Anurag-aws"),
                                             (4, "Vidhya-aws"),
                                             (5, "Michalis-aws"),
                                             (6, "Ippokratis-aws"),
                                             (7, "Mengchu-aws"),
                                             (8, "Martin-aws"), (8, "abc"),
                                             (10, "Fabian-aws"),
                                             (11, "Jenny-aws"),
                                             (12, "Yannis-aws"),
                                             (13, "Dory-aws"),
                                             (14, "Anurag-aws"),
                                             (100, "Redshift"),
                                             (2147483641, "Ippokratis-aws"),
                                             (2147483641, "Michalis-aws"),
                                             (2147483641, "Vidhya-aws")]
                # Test MERGE with SP for single WHEN clause DELETE with external table.
                cursor.execute("DELETE FROM target_e")
                cursor.execute("""
                    CREATE PROCEDURE merge_sp9(f1 bigint)
                    AS $$
                    BEGIN
                        INSERT INTO target_e VALUES (8, 'abc'), (100, 'Redshift');
                        MERGE INTO target_e USING s3_merge_test.alltypes_csv AS s
                        ON target_e.cint + f1 = s.cint + f1
                        WHEN matched THEN DELETE;
                    END;
                    $$ LANGUAGE PLPGSQL;
                """)
                self._start_and_wait_for_refresh(cluster)
                cursor.execute("SET query_group TO burst")
                cursor.execute("CALL merge_sp9(100)")
                cursor.execute(
                    "select concurrency_scaling_status from stl_query "
                    "where xid in (select xid from stl_query "
                    "where query = pg_last_query_id()) order by query")
                # This MERGE query is rewritten into DELETE.
                assert cursor.fetchall() == [(1, ), (72, )]
                # Check the target table.
                cursor.execute("SELECT * FROM target_e ORDER BY 1,2")
                assert cursor.fetchall() == [(100, 'Redshift')]
                # Test MERGE with SP for single WHEN clause UPDATE
                # with subquery from external table as source.
                cursor.execute("DELETE FROM target_e")
                cursor.execute("""
                    CREATE PROCEDURE merge_sp13(f1 bigint)
                    AS $$
                    BEGIN
                        INSERT INTO target_e VALUES (8, 'abc'), (100, 'Redshift');
                        MERGE INTO target_e USING
                        (SELECT * FROM s3_merge_test.alltypes_csv) AS s
                        ON target_e.cint = s.cint
                        WHEN matched THEN
                        UPDATE SET cint = s.cint + f1, cvarchar = s.cvarchar;
                    END;
                    $$ LANGUAGE PLPGSQL;
                """)
                self._start_and_wait_for_refresh(cluster)
                cursor.execute("SET query_group TO burst")
                cursor.execute("CALL merge_sp13(1)")
                cursor.execute(
                    "select concurrency_scaling_status from stl_query "
                    "where xid in (select xid from stl_query "
                    "where query = pg_last_query_id()) order by query")
                # This MERGE query is rewritten into UPDATE.
                assert cursor.fetchall() == [(1, ), (72, )]
                # Check the target table.
                cursor.execute("SELECT * FROM target_e ORDER BY 1,2")
                assert cursor.fetchall() == [(9, 'Meng'), (100, 'Redshift')]

                # Test MERGE with SP for single WHEN clause INSERT
                # with subquery from external table as source.
                cursor.execute("DELETE FROM target_e")
                cursor.execute("""
                    CREATE PROCEDURE merge_sp14(f1 bigint, f2 varchar(10))
                    AS $$
                    BEGIN
                        INSERT INTO target_e VALUES (8, 'abc'), (100, 'Redshift');
                        MERGE INTO target_e USING
                        (SELECT * FROM s3_merge_test.alltypes_csv) AS s
                        ON target_e.cint = s.cint
                        WHEN NOT matched THEN
                        INSERT VALUES (s.cint + f1, s.cvarchar + f2);
                    END;
                    $$ LANGUAGE PLPGSQL;
                """)
                self._start_and_wait_for_refresh(cluster)
                cursor.execute("SET query_group TO burst")
                cursor.execute("CALL merge_sp14(1, '-aws')")
                cursor.execute(
                    "select concurrency_scaling_status from stl_query "
                    "where xid in (select xid from stl_query "
                    "where query = pg_last_query_id()) order by query")
                # This MERGE query is rewritten into INSERT.
                assert cursor.fetchall() == [(1, ), (72, )]
                # Check the target table.
                cursor.execute("SELECT * FROM target_e ORDER BY 1,2")
                assert cursor.fetchall() == [(-2147483644, "Fabian-aws"),
                                             (-2147483644, "Jenny-aws"),
                                             (-2147483644, "Yannis-aws"),
                                             (0, "Meng-aws"),
                                             (1, "Martin-aws"),
                                             (2, "Mengchu-aws"),
                                             (3, "Anurag-aws"),
                                             (4, "Vidhya-aws"),
                                             (5, "Michalis-aws"),
                                             (6, "Ippokratis-aws"),
                                             (7, "Mengchu-aws"),
                                             (8, "Martin-aws"), (8, "abc"),
                                             (10, "Fabian-aws"),
                                             (11, "Jenny-aws"),
                                             (12, "Yannis-aws"),
                                             (13, "Dory-aws"),
                                             (14, "Anurag-aws"),
                                             (100, "Redshift"),
                                             (2147483641, "Ippokratis-aws"),
                                             (2147483641, "Michalis-aws"),
                                             (2147483641, "Vidhya-aws")]
                # Test MERGE with SP for single WHEN clause DELETE
                # with subquery from external table as source.
                cursor.execute("DELETE FROM target_e")
                cursor.execute("""
                    CREATE PROCEDURE merge_sp15(f1 bigint)
                    AS $$
                    BEGIN
                        INSERT INTO target_e VALUES (8, 'abc'), (100, 'Redshift');
                        MERGE INTO target_e USING
                        (SELECT * FROM s3_merge_test.alltypes_csv) AS s
                        ON target_e.cint + f1 = s.cint + f1
                        WHEN matched THEN DELETE;
                    END;
                    $$ LANGUAGE PLPGSQL;
                """)
                self._start_and_wait_for_refresh(cluster)
                cursor.execute("SET query_group TO burst")
                cursor.execute("CALL merge_sp15(100)")
                cursor.execute(
                    "select concurrency_scaling_status from stl_query "
                    "where xid in (select xid from stl_query "
                    "where query = pg_last_query_id()) order by query")
                # This MERGE query is rewritten into DELETE.
                assert cursor.fetchall() == [(1, ), (72, )]
                # Check the target table.
                cursor.execute("SELECT * FROM target_e ORDER BY 1,2")
                assert cursor.fetchall() == [(100, 'Redshift')]
        finally:
            with db_session.cursor() as cursor:
                # Clean up.
                cursor.execute("DROP TABLE IF EXISTS t1")
                cursor.execute("DROP TABLE IF EXISTS s1")
                cursor.execute("DROP TABLE IF EXISTS target_e")
                cursor.execute("DROP PROCEDURE merge_sp7(f1 bigint)")
                cursor.execute(
                    "DROP PROCEDURE merge_sp8(f1 bigint, f2 varchar(10))")
                cursor.execute("DROP PROCEDURE merge_sp9(f1 bigint)")
                cursor.execute("DROP PROCEDURE merge_sp13(f1 bigint)")
                cursor.execute(
                    "DROP PROCEDURE merge_sp14(f1 bigint, f2 varchar(10))")
                cursor.execute("DROP PROCEDURE merge_sp15(f1 bigint)")
