# Copyright 2022 Amazon.com, Inc. or its affiliates
# All Rights Reserved
import logging
import pytest

import test_burst_mv_refresh
from test_burst_mv_refresh import (TestBurstWriteMVBase, MY_USER, MY_SCHEMA,
                                   MV_QUERIES, VC_LEN)
from raff.burst.burst_super_simulated_mode_helper import super_simulated_mode
from raff.common.db.session import DbSession
from raff.common.db.session_context import SessionContext
from raff.burst.burst_write import burst_write_mv_gucs
from raff.burst.burst_test import setup_teardown_burst

log = logging.getLogger(__name__)
__all__ = [super_simulated_mode, setup_teardown_burst]

diststyle = ['diststyle even', "distkey(c0)"]
sortkey = ['sortkey(c0)', '']
DML = [
    "INSERT",
    "UPDATE",
    "DELETE",
]


@pytest.mark.serial_only
@pytest.mark.skip_load_data
class BaseTestBWIDColMV(TestBurstWriteMVBase):
    def base_test_bw_id_col_mv_refresh(self, cluster):
        """
            This test provides coverage for materialized view on burst cluster.
            This test covers following test case:
              1) creates table and corresponding materialized view
              2) runs dml on table in burst cluster
              3) check equivalence between table and materialized view
                 before and after refreshing materialized view.
        """
        # Setup the create table statement only for id col MV test
        test_burst_mv_refresh.CREATE_TABLE = (
            "CREATE TABLE IF NOT EXISTS {} ("
            " c0 int, c1 int, c2 varchar(" + str(VC_LEN) + "), "
            " c3 int default 2,"
            " c4 int default 3,"
            " c5 int default 5,"
            " c6 int default 7,"
            " c7 bigint identity(-50, 2),"
            " c8 BIGINT GENERATED BY DEFAULT AS IDENTITY(100, 3)"
            " ) {} {}")
        relprefix = "dp35925"
        session = DbSession(
            cluster.get_conn_params(),
            session_ctx=SessionContext(username=MY_USER, schema=MY_SCHEMA))
        cursor = session.cursor()
        syscur = self.db.cursor()
        with self.setup_mv(
                cluster,
                cursor,
                relprefix,
                diststyle,
                sortkey,
                MV_QUERIES,
                clean_on_exit=False):
            if self.run_on_burst:
                cursor.execute("set query_group to burst")
            syscur.execute("set search_path to {}".format(MY_SCHEMA))
            for mvd in self.mv_data(relprefix, diststyle, sortkey, MV_QUERIES):
                log.info("Run DML on burst cluster & it should burst")
                self._do_dmls(cluster, cursor, mvd, True, True, DML,
                              ["COMMIT"])

                log.info("Run DML on main cluster")
                self._do_dmls(cluster, cursor, mvd, False, False, ["INSERT"],
                              ["COMMIT"])

                self._start_and_wait_for_refresh(cluster)
                log.info(("Run DML with ABORT on burst cluster"))
                self._do_dmls(cluster, cursor, mvd, True, True, ["UPDATE"],
                              ["ABORT"])

                for tbl in mvd.tables:
                    self._check_table(cluster, MY_SCHEMA, tbl, mvd.t_dist)
        # Revert the create table statement for normal MV tests
        test_burst_mv_refresh.CREATE_TABLE = (
            "CREATE TABLE IF NOT EXISTS {} ("
            " c0 int, c1 int, c2 varchar(" + str(VC_LEN) + "), "
            " c3 int default 2,"
            " c4 int default 3,"
            " c5 int default 5,"
            " c6 int default 7"
            " ) {} {}")


@pytest.mark.super_simulated_no_stable_rc
@pytest.mark.localhost_only
@pytest.mark.super_simulated_mode
@pytest.mark.custom_burst_gucs(
    gucs=list(burst_write_mv_gucs.items()) + [
        ('slices_per_node', '3'),
        ('burst_enable_write_id_col', 'true'),
        ('mv_enable_refresh_to_burst', 'true')])
@pytest.mark.custom_local_gucs(gucs={'burst_enable_write_id_col': 'true',
                                     'mv_enable_refresh_to_burst': 'true'})
@pytest.mark.usefixtures("super_simulated_mode")
class TestBurstWriteIDColMVSS(BaseTestBWIDColMV):
    def test_bw_id_col_mv_refresh(self, cluster):
        self.base_test_bw_id_col_mv_refresh(cluster)
