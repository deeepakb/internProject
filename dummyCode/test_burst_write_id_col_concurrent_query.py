# Copyright 2021 Amazon.com, Inc. or its affiliates
# All Rights Reserved
import logging
import pytest

from raff.burst.burst_write_id_col import BurstWriteIdentityColumnBase
from raff.burst.burst_super_simulated_mode_helper import super_simulated_mode
from raff.common.dimensions import Dimensions
from raff.storage.storage_test import create_thread

__all__ = [super_simulated_mode]
log = logging.getLogger(__name__)
INSERT_STMT_T1 = "insert into {}.bw_t1(c0) values(10);"
INSERT_STMT_T2 = "insert into {}.bw_t2(c0) values(10);"
INSERT_SELECT_STMT = ("insert into bw_t1(c0) select c0 from bw_t2;")
INSERT_SELECT_STMT_2 = ("insert into bw_t2(c0) select c0 from bw_t1;")
MAIN_OWNED = [('Main', 'Owned')]
MAIN_UNDO = [('Main', 'Undo')]
BURST_OWNED = [('Burst', 'Owned')]


@pytest.mark.serial_only
@pytest.mark.localhost_only
@pytest.mark.skip_load_data
@pytest.mark.super_simulated_mode
@pytest.mark.usefixtures("super_simulated_mode")
@pytest.mark.custom_burst_gucs(
    gucs={
        'slices_per_node': '4',
        'burst_enable_write': 'true',
        'burst_enable_write_id_col': 'true'
    })
@pytest.mark.custom_local_gucs(gucs={'burst_enable_write_id_col': 'true'})
class TestBurstWriteIdColConcurrentQuery(BurstWriteIdentityColumnBase):
    @classmethod
    def modify_test_dimensions(cls):
        return Dimensions({
            "guard": [
                'burst:check_backup', 'burst:find_cluster',
                'burst:found_cluster', 'burst_write:pre_write_lock'
            ],
            "is_owned_table": [True, False]
        })

    def _setup_tables(self, db_session, schema):
        with db_session.cursor() as cursor:
            cursor.execute("begin;")
            cursor.execute(
                "create table bw_t1(c0 int, c1 bigint identity(0, 1),"
                "c2 BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL)"
                " diststyle even;")
            cursor.execute(
                "create table bw_t2(c0 int, c1 bigint identity(0, 1),"
                "c2 BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL)"
                " distkey(c0);")
            cursor.execute("select * from bw_t1;")
            cursor.execute("select * from bw_t2;")
            cursor.execute("insert into bw_t1(c0) values(0),(1),(2),(3)")
            cursor.execute("insert into bw_t2(c0) values(0),(1),(2),(3)")
            for i in range(3):
                cursor.execute("insert into bw_t1(c0) select c0 from bw_t1;")
                cursor.execute("insert into bw_t2(c0) select c0 from bw_t2;")
            cursor.execute("commit;")

    def _init_check(self, cluster, cursor, schema):
        self._validate_identity_column_data(cluster, cursor)
        self._validate_ownership_state(schema, 'bw_t1', [])
        self._validate_ownership_state(schema, 'bw_t2', [])
        # make burst cluster owns bw_t1 and bw_t2
        cursor.execute("set query_group to burst;")
        cursor.execute("begin;")
        cursor.execute("insert into bw_t1(c0) values(0),(1),(2),(3)")
        self._check_last_query_bursted(cluster, cursor)
        self._validate_ownership_state(schema, 'bw_t1', BURST_OWNED)
        cursor.execute("insert into bw_t2(c0) values(0),(1),(2),(3)")
        self._check_last_query_bursted(cluster, cursor)
        self._validate_ownership_state(schema, 'bw_t2', BURST_OWNED)
        cursor.execute("commit")
        self._validate_ownership_state(schema, 'bw_t1', BURST_OWNED)
        self._validate_ownership_state(schema, 'bw_t2', BURST_OWNED)

    def _do_background_query(self, cluster, cursor, schema, query, is_bursted):
        cursor.execute('set query_group to burst;')
        cursor.execute(query)
        if is_bursted:
            self._check_last_query_bursted(cluster, cursor)
        else:
            self._check_last_query_didnt_burst(cluster, cursor)

    def _close_test(self, cluster, cursor, schema):
        cursor.execute("insert into bw_t1(c0) values(10)")
        self._check_last_query_bursted(cluster, cursor)
        cursor.execute("insert into bw_t2(c0) values(10)")
        self._check_last_query_bursted(cluster, cursor)
        self._validate_ownership_state(schema, 'bw_t1', BURST_OWNED)
        self._validate_ownership_state(schema, 'bw_t2', BURST_OWNED)
        self._validate_table(cluster, schema, 'bw_t1', 'even')
        self._validate_table(cluster, schema, 'bw_t2', 'distkey')
        cursor.execute("drop table bw_t1;")
        cursor.execute("drop table bw_t2;")

    def _should_burst(self, vector, is_commit):
        return (vector.guard == 'burst:found_cluster' or
                not vector.is_owned_table) and \
               (is_commit or vector.guard != 'burst_write:pre_write_lock')

    def _abort_dml_txn(self, schema):
        with self.db.cursor() as bootstrap_cursor:
            bootstrap_cursor.execute("xpx 'event set EtBurstWriteGuard'")
            bootstrap_cursor.execute("begin;")
            bootstrap_cursor.execute(INSERT_STMT_T2.format(schema))
            self._validate_ownership_state(schema, 'bw_t2', MAIN_OWNED)
            bootstrap_cursor.execute("abort;")
            self._validate_ownership_state(schema, 'bw_t2', MAIN_UNDO)
            bootstrap_cursor.execute("xpx 'event unset EtBurstWriteGuard'")

    def _validate_identity_column_data(self, cluster, cursor):
        self._start_and_wait_for_refresh(cluster)
        self._check_duplicated_id_col_values(cursor, "bw_t1", "c1", "(-10)",
                                             True)
        self._check_duplicated_id_col_values(cursor, "bw_t1", "c2", "(-10)",
                                             True)
        self._check_duplicated_id_col_values(cursor, "bw_t2", "c1", "(-10)",
                                             True)
        self._check_duplicated_id_col_values(cursor, "bw_t2", "c2", "(-10)",
                                             True)

    def test_bw_id_col_with_concurrent_undo(self, cluster, vector, db_session):
        """
        Test: Block write query on different burst qualification position and
              undo dml on table referred by write query in background.
              Validate id cols high watermark by checking new id col values are
              still unique.
        """
        schema = db_session.session_ctx.schema
        with db_session.cursor() as cursor:
            cursor.execute("set query_group to burst;")
            self._setup_tables(db_session, schema)
            self._start_and_wait_for_refresh(cluster)
            if vector.is_owned_table:
                self._init_check(cluster, cursor, schema)
            is_bursted = self._should_burst(vector, False)
            params = (cluster, cursor, schema, INSERT_SELECT_STMT, is_bursted)
            with create_thread(self._do_background_query, params) as thread, \
                    self._create_xen_guard(vector.guard) as xen_guard:
                log.info("Background query started")
                thread.start()
                xen_guard.wait_until_process_blocks()
                log.info("Background query unblocked")
                self._abort_dml_txn(schema)
                xen_guard.disable()
            # Since it is write query, bw_t1 is in BURST_OWNED state only if
            # the write query is burted.
            bw_t1_state = BURST_OWNED if is_bursted else []
            self._validate_ownership_state(schema, 'bw_t1', bw_t1_state)
            # Since write query on bw_t2 is aborted, bw_t2 must be MAIN_UNDO
            # state.
            self._validate_ownership_state(schema, 'bw_t2', MAIN_UNDO)
            self._start_and_wait_for_refresh(cluster)
            # check burst cluster table content
            cursor.execute("set query_group to burst;")
            cursor.execute(INSERT_SELECT_STMT)
            cursor.execute(INSERT_SELECT_STMT_2)
            self._validate_identity_column_data(cluster, cursor)
            self._check_last_query_bursted(cluster, cursor)
            self._close_test(cluster, cursor, schema)

    def _commit_dml(self, schema, xen_guard, concurrent_thread):
        with self.db.cursor() as bootstrap_cursor:
            bootstrap_cursor.execute("xpx 'event set EtBurstWriteGuard'")
            bootstrap_cursor.execute("begin;")
            bootstrap_cursor.execute(INSERT_STMT_T2.format(schema))
            self._validate_ownership_state(schema, 'bw_t2', MAIN_OWNED)
            xen_guard.disable()
            concurrent_thread.join()
            bootstrap_cursor.execute("commit;")
            self._validate_ownership_state(schema, 'bw_t2', [])
            bootstrap_cursor.execute("xpx 'event unset EtBurstWriteGuard'")

    def test_bw_id_col_with_concurrent_dml(self, cluster, vector, db_session):
        """
        Test: Block write query on different burst qualification position and
              commit dml on owned tables in background. Check the burst
              qualification works correctly.
        """
        schema = db_session.session_ctx.schema
        with db_session.cursor() as cursor:
            cursor.execute("set query_group to burst;")
            self._setup_tables(db_session, schema)
            self._start_and_wait_for_refresh(cluster)
            if vector.is_owned_table:
                self._init_check(cluster, cursor, schema)
            is_bursted = self._should_burst(vector, True)
            params = (cluster, cursor, schema, INSERT_SELECT_STMT, is_bursted)
            with create_thread(self._do_background_query, params) as thread, \
                    self._create_xen_guard(vector.guard) as xen_guard:
                thread.start()
                xen_guard.wait_until_process_blocks()
                self._commit_dml(schema, xen_guard, thread)
            # Since it is write query, bw_t1 is in BURST_OWNED state only if
            # the write query is burted.
            bw_t1_state = BURST_OWNED if is_bursted else []
            self._validate_ownership_state(schema, 'bw_t1', bw_t1_state)
            # Since write query on bw_t2 is ran on main cluster, then bw_t2's
            # state is empty.
            self._validate_ownership_state(schema, 'bw_t2', [])
            self._start_and_wait_for_refresh(cluster)
            # check table ownership after backup and refresh.
            self._validate_ownership_state(schema, 'bw_t1', bw_t1_state)
            self._validate_ownership_state(schema, 'bw_t2', [])
            # check burst cluster table content
            cursor.execute("set query_group to burst;")
            cursor.execute(INSERT_SELECT_STMT)
            cursor.execute(INSERT_SELECT_STMT_2)
            self._validate_identity_column_data(cluster, cursor)
            cursor.execute("set query_group to burst;")
            self._close_test(cluster, cursor, schema)
