# Copyright 2019 Amazon.com, Inc. or its affiliates
# All Rights Reserved

import pytest

from raff.burst.burst_test import (BurstTest, setup_teardown_burst)
from raff.common.aws_clients.redshift_client import RedshiftClient
from raff.common.cred_helper import get_role_auth_str
from raff.common.profile import AwsAccounts
from raff.common.profile import Profiles
from raff.common.region import Regions

# Trick to get around claim of unused import even though it is used in the
# usefixtures marker.
__all__ = ["setup_teardown_burst"]

CUSTOM_GUCS = {
    'burst_disable_volt_tts_on_failure': 'false',
    'burst_enable_volt_tts': 'true',
    'burst_mode': '3',
    'burst_volt_tts_require_replay': 'false',
    'enable_burst_failure_handling': 'true'
}

TPCDS_Q1_SQL = """
      {}
      WITH /* TPC-DS query1.tpl 0.12 */ customer_total_return AS
          (SELECT sr_customer_sk AS ctr_customer_sk,
                  sr_store_sk AS ctr_store_sk,
                  sum(SR_STORE_CREDIT) AS ctr_total_return
           FROM store_returns,
                date_dim
           WHERE sr_returned_date_sk = d_date_sk
             AND d_year =2000
           GROUP BY sr_customer_sk,
                    sr_store_sk)
        SELECT /* TPC-DS query1.tpl 0.12 */ top 100 c_customer_id
        FROM customer_total_return ctr1,
             store,
             customer
        WHERE ctr1.ctr_total_return >
            (SELECT avg(ctr_total_return)*1.2
             FROM customer_total_return ctr2
             WHERE ctr1.ctr_store_sk = ctr2.ctr_store_sk)
          AND s_store_sk = ctr1.ctr_store_sk
          AND s_state = 'MI'
          AND ctr1.ctr_customer_sk = c_customer_sk
        ORDER BY c_customer_id;
"""


@pytest.mark.serial_only
@pytest.mark.cluster_only
@pytest.mark.custom_burst_gucs(gucs=CUSTOM_GUCS)
@pytest.mark.load_tpcds_data
@pytest.mark.usefixtures("setup_teardown_burst")
class TestVoltTTFailureNoReplay(BurstTest):
    """
    Tests that failures when Bursting Volt TTs are not retried but propagated to
    the user. This does not apply to the first CTAS generated by the Volt query
    though because it does not create any state on the Burst cluster.
    """

    def get_burst_cluster(self, burst_cluster_arn):
        profile_obj = Profiles.get_by_name(Profiles.QA_BURST_TEST.name)
        burst_client = RedshiftClient(profile=profile_obj, region=Regions.QA)
        burst_cluster_name = burst_cluster_arn.split(':cluster:')[-1].strip()
        burst_cluster = burst_client.describe_cluster(burst_cluster_name)
        return burst_cluster

    def test_burst_volt_tt_failure_no_replay(self, cluster, db_session,
                                             s3_client):
        # Setup
        burst_cluster_arns = cluster.list_acquired_burst_clusters()
        burst_cluster = self.get_burst_cluster(burst_cluster_arns[0])
        IAM_CREDENTIAL = get_role_auth_str(
            AwsAccounts.DP.iam_roles.Redshift_S3_Write)
        TEST_S3_PATH = ("s3://cookie-monster-s3-ingestion/"
                        "raff_test_burst_unload/{}/{}/")

        # Ensure that the queries succeed if we fail the first Volt-generated
        # CTAS.
        burst_cluster.set_event('EtFailNthBurstQueries,frequency={}'.format(1))
        # Prepare
        with self.burst_db_cursor(db_session) as cursor:
            cursor.execute(TPCDS_Q1_SQL.format("PREPARE p1 AS "))
            cursor.execute("EXECUTE p1;")
            assert cursor.fetchall() == []
            cursor.execute("DEALLOCATE p1;")
        # Unload
        rand_str = self._generate_random_string()
        unload_path = TEST_S3_PATH.format('volt_tt_failure_no_replay',
                                          rand_str)
        with self.unload_session(unload_path, s3_client):
            with self.burst_db_cursor(db_session) as cursor:
                # Note: UNLOAD does not support LIMIT.
                cursor.run_unload(
                    TPCDS_Q1_SQL.format("").replace("\'", "\\'").replace(
                        " top 100", ""), unload_path, IAM_CREDENTIAL)
                assert cursor.last_unload_row_count() == 0

        # Ensure that the queries fail if we fail the second and final query.
        error_msg = '.*Simulated Burst query failure.*'
        burst_cluster.set_event('EtFailNthBurstQueries,frequency={}'.format(2))
        # Prepare
        with self.burst_db_cursor(db_session) as cursor:
            cursor.execute(TPCDS_Q1_SQL.format("PREPARE p1 AS "))
            self.execute_failing_query("EXECUTE p1;", error_msg, db_session)
            cursor.execute("DEALLOCATE p1;")

        # Unload
        rand_str = self._generate_random_string()
        unload_path = TEST_S3_PATH.format('volt_tt_failure_no_replay',
                                          rand_str)
        with self.unload_session(unload_path, s3_client):
            with self.burst_db_cursor(db_session) as cursor:
                # Note: UNLOAD does not support LIMIT.
                self.execute_failing_unload(
                    select_stmt=TPCDS_Q1_SQL.format("").replace(
                        "\'", "\\'").replace(" top 100", ""),
                    data_dest=unload_path,
                    error_regex=error_msg,
                    auth=IAM_CREDENTIAL,
                    session=db_session)
