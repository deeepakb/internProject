# Copyright 2021 Amazon.com, Inc. or its affiliates
# All Rights Reserved
import logging
import pytest

from raff.burst.burst_super_simulated_mode_helper import (super_simulated_mode,
                                                          get_burst_conn_params)
from raff.burst.burst_temp_write import BurstTempWrite, burst_user_temp_support_gucs
from raff.common.db.session import DbSession
from raff.common.dimensions import Dimensions
from raff.common.db.redshift_db import RedshiftDb
from raff.common.host_type import HostType
from raff.burst.burst_write import burst_write_basic_gucs
from raff.burst.burst_test import setup_teardown_burst
from raff.util.utils import run_bootstrap_sql

log = logging.getLogger(__name__)
__all__ = [super_simulated_mode, setup_teardown_burst]


class BurstWriteIdentityColumnBase(BurstTempWrite):
    def run_privileged_query_no_result(self, cluster, bootstrap_cursor, query):
        if cluster.host_type == HostType.CLUSTER:
            run_bootstrap_sql(cluster, query, 'dev')
        else:
            bootstrap_cursor.execute(query)

    def _set_fixslice_event(self, cluster):
        fixed_slice_set = "xpx 'event set EtSimulateStartFromFixedSlice'"
        with self.db.cursor() as cursor:
            self.run_privileged_query_no_result(cluster, cursor,
                                                fixed_slice_set)

        burst_db = RedshiftDb(conn_params=get_burst_conn_params())
        with burst_db.cursor() as burst_cursor:
            burst_cursor.execute(fixed_slice_set)

    def _unset_fixslice_event(self, cluster):
        fixed_slice_set = "xpx 'event unset EtSimulateStartFromFixedSlice'"
        with self.db.cursor() as cursor:
            self.run_privileged_query_no_result(cluster, cursor,
                                                fixed_slice_set)

        burst_db = RedshiftDb(conn_params=get_burst_conn_params())
        with burst_db.cursor() as burst_cursor:
            burst_cursor.execute(fixed_slice_set)

    def _setup_tables(self, cluster, cursor, vector, ssm_should_run_temp=False):
        diststyle = vector.diststyle
        sortkey = vector.sortkey
        table_type = 'temp' if ssm_should_run_temp else ''
        tbl_def = (
            "create {} table dp31285_tbl(c0 int, c1 bigint identity(0, 1),"
            "c2 BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL) {} {}")
        tbl_def_burst = (
            "create {} table dp31285_tbl_burst(c0 int, c1 bigint identity(0, 1),"
            "c2 BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL) {} {}")
        tbl_def_commit = ("create table dp31285_tbl_commit(c0 int)")
        cursor.execute(tbl_def.format(table_type, diststyle, sortkey))
        cursor.execute(tbl_def_burst.format(table_type, diststyle, sortkey))
        cursor.execute(tbl_def_commit)
        if vector.fix_slice:
            self._set_fixslice_event(cluster)

    def _insert_identity_data(self, cluster, cursor, iteration_num, main_table,
                              burst_table):
        basic_insert = ("insert into {}(c0, c2) values({}, default);")
        basic_insert_2 = ("insert into {}(c0, c2) values({}, -10);")
        # Burst query
        cursor.execute("set query_group to burst;")
        cursor.execute("begin;")
        for i in range(iteration_num):
            log.info("Burst insert iteration {} {}".format(burst_table, i))
            cursor.execute(basic_insert.format(burst_table, i))
            self._check_last_query_bursted(cluster, cursor)
            cursor.execute(basic_insert_2.format(burst_table, i))
            self._check_last_query_bursted(cluster, cursor)
        cursor.execute("commit;")
        # Normal query
        cursor.execute("set query_group to metrics;")
        cursor.execute("begin;")
        for i in range(iteration_num):
            log.info("Main insert iteration {} {}".format(main_table, i))
            cursor.execute(basic_insert.format(main_table, i))
            self._check_last_query_didnt_burst(cluster, cursor)
            cursor.execute(basic_insert_2.format(main_table, i))
            self._check_last_query_didnt_burst(cluster, cursor)
        cursor.execute("commit;")

    def _insert_select(self, cluster, cursor, iteration_num, main_table,
                       burst_table):
        query_1 = ("insert into {}(c0) select c0 from {};")
        query_2 = ("insert into {}(c0, c2) select c0, c2 from {};")
        # Burst query
        cursor.execute("set query_group to burst;")
        cursor.execute("begin;")
        for i in range(iteration_num):
            log.info("Burst insert select iteration {} {}".format(
                burst_table, i))
            cursor.execute(query_1.format(burst_table, burst_table))
            self._check_last_query_bursted(cluster, cursor)
            cursor.execute(query_2.format(burst_table, burst_table))
            self._check_last_query_bursted(cluster, cursor)
        cursor.execute("commit;")
        # Normal query
        cursor.execute("set query_group to metrics;")
        cursor.execute("begin;")
        for i in range(iteration_num):
            log.info("Main insert select iteration {} {}".format(
                main_table, i))
            cursor.execute(query_1.format(main_table, main_table))
            self._check_last_query_didnt_burst(cluster, cursor)
            cursor.execute(query_2.format(main_table, main_table))
            self._check_last_query_didnt_burst(cluster, cursor)
        cursor.execute("commit;")

    def _insert_identity_data_abort(self, cluster, cursor, iteration_num,
                                    main_table, burst_table):
        basic_insert_1 = ("insert into {}(c0, c2) values({}, default);")
        basic_insert_2 = ("insert into {}(c0, c2) values({}, -10);")
        # Normal query
        cursor.execute("set query_group to metrics;")
        for i in range(iteration_num):
            log.info("Main insert iteration {} {}".format(main_table, i))
            cursor.execute("begin;")
            cursor.execute(basic_insert_1.format(main_table, i))
            self._check_last_query_didnt_burst(cluster, cursor)
            cursor.execute(basic_insert_2.format(main_table, i))
            self._check_last_query_didnt_burst(cluster, cursor)
            if i % 2 == 0:
                cursor.execute("commit;")
            else:
                cursor.execute("abort;")
        # Burst query
        cursor.execute("set query_group to burst;")
        for i in range(iteration_num):
            log.info("Burst insert iteration {} {}".format(burst_table, i))
            cursor.execute("begin;")
            cursor.execute(basic_insert_1.format(burst_table, i))
            self._check_last_query_bursted(cluster, cursor)
            cursor.execute(basic_insert_2.format(burst_table, i))
            self._check_last_query_bursted(cluster, cursor)
            if i % 2 == 0:
                cursor.execute("commit;")
            else:
                cursor.execute("abort;")
                # Trigger local commit and backup for next burst after abort
                cursor.execute("set query_group to metrics;")
                cursor.execute("insert into dp31285_tbl_commit values(1);")
                self._start_and_wait_for_refresh(cluster)
                cursor.execute("set query_group to burst;")

    def _insert_select_abort(self, cluster, cursor, iteration_num, main_table,
                             burst_table):
        insert_1 = ("insert into {}(c0) select c0 from {};")
        insert_2 = ("insert into {}(c0, c2) select c0, c2 from {};")
        # Normal query
        cursor.execute("set query_group to metrics;")
        for i in range(iteration_num):
            log.info("Main insert iteration {} {}".format(main_table, i))
            cursor.execute("begin;")
            cursor.execute(insert_1.format(main_table, main_table))
            self._check_last_query_didnt_burst(cluster, cursor)
            cursor.execute(insert_2.format(main_table, main_table))
            self._check_last_query_didnt_burst(cluster, cursor)
            if i % 2 == 0:
                cursor.execute("commit;")
            else:
                cursor.execute("abort;")
        # Burst query
        cursor.execute("set query_group to burst;")
        for i in range(iteration_num):
            log.info("Burst insert iteration {} {}".format(burst_table, i))
            cursor.execute("begin;")
            cursor.execute(insert_1.format(burst_table, burst_table))
            self._check_last_query_bursted(cluster, cursor)
            cursor.execute(insert_2.format(burst_table, burst_table))
            self._check_last_query_bursted(cluster, cursor)
            if i % 2 == 0:
                cursor.execute("commit;")
            else:
                cursor.execute("abort;")
                # Trigger local commit and backup for next burst after abort
                cursor.execute("set query_group to metrics;")
                cursor.execute("insert into dp31285_tbl_commit values(1);")
                self._start_and_wait_for_refresh(cluster)
                cursor.execute("set query_group to burst;")

    def _assert_tables_diff(self, cursor, on_burst, res_1, res_2):
        query_group = "Burst" if on_burst else "Main"
        assert len(res_1) == 0
        assert len(res_2) == 0
        log.info("{} Cluster result check done".format(query_group))

    def _check_duplicated_id_col_values(self, cursor, tbl_name, colname,
                                        user_id_values, burst):
        # query to check duplicated identity values
        check_sql_raw = ("select {}, count(*) from {}"
                         " where {} not in {} group by {} "
                         "having count(*) > 1 order by 1;")
        identity_check_sql = check_sql_raw.format(colname, tbl_name, colname,
                                                  user_id_values, colname)
        if burst:
            cursor.execute("set query_group to burst;")
        else:
            cursor.execute("set query_group to metrics;")
        cursor.execute(identity_check_sql)
        row_counts = cursor.fetchall()
        try:
            assert len(row_counts) == 0
        except AssertionError:
            log.info("{} {} duplicates id rows count: {}".format(
                tbl_name, colname, row_counts))
            assert len(row_counts) == 0

    def _check_all_id_cols_not_duplicated(self, cursor, tbl_name):
        self._check_duplicated_id_col_values(cursor, tbl_name, "c1", "(-10)",
                                             False)
        self._check_duplicated_id_col_values(cursor, tbl_name, "c1", "(-10)",
                                             True)
        self._check_duplicated_id_col_values(cursor, tbl_name, "c2", "(-10)",
                                             False)
        self._check_duplicated_id_col_values(cursor, tbl_name, "c2", "(-10)",
                                             True)

    def _validate_one_id_col_data(self, cluster, cursor, tbl, col, on_burst,
                                  fix_slice):
        burst_tbl = tbl + "_burst"
        # two tables should contain same number of id values
        check_sql_raw_1 = ("select {col}, count(*) from {tbl} group by {col} "
                           "except select {col}, count(*) from {tbl_burst} "
                           "group by {col}")
        check_sql_raw_2 = ("select {col}, count(*) from {tbl_burst}"
                           " group by {col} "
                           "except select {col}, count(*) from {tbl}"
                           " group by {col}")
        identity_check_sql_1 = check_sql_raw_1.format(
            col=col, tbl=tbl, tbl_burst=burst_tbl)
        identity_check_sql_2 = check_sql_raw_2.format(
            col=col, tbl=tbl, tbl_burst=burst_tbl)
        if on_burst:
            cursor.execute("set query_group to burst;")
        else:
            cursor.execute("set query_group to metrics;")
        cursor.execute(identity_check_sql_1)
        res_1 = cursor.fetchall()
        if on_burst:
            self._check_last_query_bursted(cluster, cursor)
        else:
            self._check_last_query_didnt_burst(cluster, cursor)

        cursor.execute(identity_check_sql_2)
        res_2 = cursor.fetchall()
        if on_burst:
            self._check_last_query_bursted(cluster, cursor)
        else:
            self._check_last_query_didnt_burst(cluster, cursor)
        log.info("Validation on {} {}".format(tbl, col))
        # If the test is running without fix slice event, or work-stealing
        # for compress step is enabled, the id values generated between main
        # and burst clusters are possibly different.
        # In this case, we only need to make sure all id values are unique.
        skip_check_tables_diff = not fix_slice or \
            cluster.get_guc_value('enable_workstealing_for_compress') == 'on'
        try:
            self._assert_tables_diff(cursor, on_burst, res_1, res_2)
        except AssertionError as e:
            if skip_check_tables_diff:
                # We do not check duplicate values on column c2 because
                # c2 is with default option and can have many duplicate values
                # after INSERT SELECT c0, c2 statement.
                if col == "c2":
                    return
                self._check_duplicated_id_col_values(cursor, tbl, col, "(-10)",
                                                     on_burst)
            else:
                log.info("On burst: {} Cluster RESULT_1: {}".format(
                    on_burst, str(res_1)))
                log.info("On burst: {} Cluster RESULT_2: {}".format(
                    on_burst, str(res_2)))
                raise e

    def _validate_identity_column_data(self, cluster, cursor, fix_slice):
        self._start_and_wait_for_refresh(cluster)
        self._validate_one_id_col_data(cluster, cursor, "dp31285_tbl", "c1",
                                       False, fix_slice)
        self._validate_one_id_col_data(cluster, cursor, "dp31285_tbl", "c1",
                                       True, fix_slice)
        self._validate_one_id_col_data(cluster, cursor, "dp31285_tbl", "c2",
                                       False, fix_slice)
        self._validate_one_id_col_data(cluster, cursor, "dp31285_tbl", "c2",
                                       True, fix_slice)


class BurstWriteIdentityColumn(BurstWriteIdentityColumnBase):
    def base_burst_write_on_id_col_commit(self, cluster, vector, is_temp=False):
        """
        Test: burst read and write on identity column.
        The test create two tables with the same identity columns.
        And then insert same data in two tables but one on main cluster and
        the other one on burst cluster. They should contain same data at last.
        """
        if vector.diststyle == 'distkey(c1)' and vector.fix_slice:
            pytest.skip("No need to test this vector")

        db_session = DbSession(cluster.get_conn_params(user='master'))
        with db_session.cursor() as cursor:
            cursor.execute("set query_group to burst;")
            self._setup_tables(cluster, cursor, vector, is_temp)
            self._start_and_wait_for_refresh(cluster)
            log.info("test generate id values from LN")
            self._insert_identity_data(cluster, cursor, 10, "dp31285_tbl",
                                       "dp31285_tbl_burst")
            log.info("Begin validation 1")
            self._validate_identity_column_data(cluster, cursor,
                                                vector.fix_slice)
            self._start_and_wait_for_refresh(cluster)
            log.info("test generate id values from CN")
            self._insert_select(cluster, cursor, 5, "dp31285_tbl",
                                "dp31285_tbl_burst")
            log.info("Begin validation 2")
            self._validate_identity_column_data(cluster, cursor,
                                                vector.fix_slice)
        if vector.fix_slice:
            self._unset_fixslice_event(cluster)

    def base_burst_write_on_id_col_interleave_commit(self, cluster, vector,
                                                     is_temp=False):
        """
        Test: burst read and write on identity column.
        The test create two tables with the same identity columns.
        Insert data on each table interleaved on main and burst clusters.
        These tables should contain same data at last.
        """
        if vector.diststyle == 'distkey(c1)' and vector.fix_slice:
            pytest.skip("No need to test this vector")

        db_session = DbSession(cluster.get_conn_params(user='master'))
        with db_session.cursor() as cursor:
            cursor.execute("set query_group to burst;")
            self._setup_tables(cluster, cursor, vector, is_temp)
            self._start_and_wait_for_refresh(cluster)
            # test generate id values from LN
            self._insert_identity_data(cluster, cursor, 1, "dp31285_tbl",
                                       "dp31285_tbl_burst")
            log.info("Begin validation 1")
            self._validate_identity_column_data(cluster, cursor,
                                                vector.fix_slice)
            self._start_and_wait_for_refresh(cluster)
            self._insert_identity_data(cluster, cursor, 2, "dp31285_tbl_burst",
                                       "dp31285_tbl")
            log.info("Begin validation 2")
            self._validate_identity_column_data(cluster, cursor,
                                                vector.fix_slice)
            self._start_and_wait_for_refresh(cluster)
            self._insert_identity_data(cluster, cursor, 2, "dp31285_tbl",
                                       "dp31285_tbl_burst")
            log.info("Begin validation 3")
            self._validate_identity_column_data(cluster, cursor,
                                                vector.fix_slice)
            # test generate id values from CN
            self._insert_select(cluster, cursor, 3, "dp31285_tbl",
                                "dp31285_tbl_burst")
            self._start_and_wait_for_refresh(cluster)
            self._validate_identity_column_data(cluster, cursor,
                                                vector.fix_slice)
            self._insert_select(cluster, cursor, 3, "dp31285_tbl_burst",
                                "dp31285_tbl")
            self._start_and_wait_for_refresh(cluster)
            self._validate_identity_column_data(cluster, cursor,
                                                vector.fix_slice)
            self._insert_select(cluster, cursor, 3, "dp31285_tbl",
                                "dp31285_tbl_burst")
            self._validate_identity_column_data(cluster, cursor,
                                                vector.fix_slice)
        if vector.fix_slice:
            self._unset_fixslice_event(cluster)

    def base_burst_write_on_id_col_abort(self, cluster, vector, is_temp=False):
        """
        Test: burst read and write on identity column with some aborted txn.
        The test create two tables with the same identity columns.
        And then insert same data in two tables but one on main cluster and
        the other one on burst cluster. They should contain same data at last.
        """
        if vector.diststyle == 'distkey(c1)' and vector.fix_slice:
            pytest.skip("No need to test this vector")

        db_session = DbSession(cluster.get_conn_params(user='master'))
        with db_session.cursor() as cursor:
            cursor.execute("set query_group to burst;")
            self._setup_tables(cluster, cursor, vector, is_temp)
            self._start_and_wait_for_refresh(cluster)
            # test generate id values from LN
            self._insert_identity_data_abort(
                cluster, cursor, 10, "dp31285_tbl", "dp31285_tbl_burst")
            log.info("Begin validation")
            self._validate_identity_column_data(cluster, cursor,
                                                vector.fix_slice)
            # test generate id values from CN
            self._start_and_wait_for_refresh(cluster)
            self._insert_select_abort(cluster, cursor, 10, "dp31285_tbl",
                                      "dp31285_tbl_burst")
            self._validate_identity_column_data(cluster, cursor,
                                                vector.fix_slice)
        if vector.fix_slice:
            self._unset_fixslice_event(cluster)

    def base_burst_write_on_id_col_interleave_abort(self, cluster, vector,
                                                    is_temp=False):
        """
        Test: burst read and write on identity column.
        The test create two tables with the same identity columns.
        Insert data on each table interleaved on main and burst clusters.
        These tables should contain same data at last.
        """
        if vector.diststyle == 'distkey(c1)' and vector.fix_slice:
            pytest.skip("No need to test this vector")

        db_session = DbSession(cluster.get_conn_params(user='master'))
        with db_session.cursor() as cursor:
            cursor.execute("set query_group to burst;")
            self._setup_tables(cluster, cursor, vector, is_temp)
            self._start_and_wait_for_refresh(cluster)
            # test generate id values from LN
            self._insert_identity_data_abort(cluster, cursor, 2, "dp31285_tbl",
                                             "dp31285_tbl_burst")
            self._validate_identity_column_data(cluster, cursor,
                                                vector.fix_slice)
            self._start_and_wait_for_refresh(cluster)
            self._insert_identity_data_abort(
                cluster, cursor, 2, "dp31285_tbl_burst", "dp31285_tbl")
            self._validate_identity_column_data(cluster, cursor,
                                                vector.fix_slice)
            self._start_and_wait_for_refresh(cluster)
            self._insert_identity_data_abort(cluster, cursor, 2, "dp31285_tbl",
                                             "dp31285_tbl_burst")
            self._validate_identity_column_data(cluster, cursor,
                                                vector.fix_slice)
            # test generate id values from CN
            self._start_and_wait_for_refresh(cluster)
            self._insert_select_abort(cluster, cursor, 3, "dp31285_tbl",
                                      "dp31285_tbl_burst")
            self._validate_identity_column_data(cluster, cursor,
                                                vector.fix_slice)
            self._start_and_wait_for_refresh(cluster)
            self._insert_select_abort(cluster, cursor, 3, "dp31285_tbl_burst",
                                      "dp31285_tbl")
            self._validate_identity_column_data(cluster, cursor,
                                                vector.fix_slice)
            self._start_and_wait_for_refresh(cluster)
            self._insert_select_abort(cluster, cursor, 3, "dp31285_tbl",
                                      "dp31285_tbl_burst")
            self._validate_identity_column_data(cluster, cursor,
                                                vector.fix_slice)
        if vector.fix_slice:
            self._unset_fixslice_event(cluster)


@pytest.mark.serial_only
@pytest.mark.localhost_only
@pytest.mark.skip_load_data
@pytest.mark.super_simulated_mode
@pytest.mark.ssm_perm_or_temp_config
@pytest.mark.usefixtures("super_simulated_mode")
@pytest.mark.custom_burst_gucs(
            gucs=dict(
                list(burst_user_temp_support_gucs.items()) + [(
                    'burst_enable_write_id_col', 'true'), ('slices_per_node', '3'),
                    ('burst_enable_write', 'true')]))
@pytest.mark.custom_local_gucs(gucs=dict(
                list(burst_user_temp_support_gucs.items()) + [(
                    'burst_enable_write_id_col', 'true')]))
class TestBurstWriteIdentityColumnSSmode(BurstWriteIdentityColumn):
    @classmethod
    def modify_test_dimensions(cls):
        return Dimensions(
            dict(
                diststyle=['distkey(c1)', 'diststyle even'],
                sortkey=['', 'compound sortkey(c0, c1)'],
                fix_slice=[False, True]))

    def test_burst_write_on_id_col_commit(self, cluster, vector, is_temp):
        self.base_burst_write_on_id_col_commit(cluster, vector, is_temp)

    def test_burst_write_on_id_col_interleave_commit(self, cluster, vector, is_temp):
        self.base_burst_write_on_id_col_interleave_commit(cluster, vector, is_temp)


@pytest.mark.serial_only
@pytest.mark.cluster_only
@pytest.mark.custom_burst_gucs(
            gucs=dict(
                list(burst_user_temp_support_gucs.items()) + [(
                    'burst_enable_write_id_col', 'true'),
                    ('burst_enable_write', 'true')]))
@pytest.mark.custom_local_gucs(gucs=dict(
                list(burst_user_temp_support_gucs.items()) + [(
                    'burst_enable_write_id_col', 'true')]))
@pytest.mark.usefixtures("setup_teardown_burst")
class TestBurstWriteIdentityColumnCluster(BurstWriteIdentityColumn):
    @classmethod
    def modify_test_dimensions(cls):
        return Dimensions(
            dict(
                diststyle=['distkey(c1)', 'diststyle even'],
                sortkey=['', 'compound sortkey(c0, c1)'],
                fix_slice=[False]))

    @pytest.mark.parametrize("is_temp", [True, False])
    def test_burst_write_on_id_col_commit(self, cluster, vector, is_temp):
        self.base_burst_write_on_id_col_commit(cluster, vector, is_temp)

    @pytest.mark.parametrize("is_temp", [True, False])
    def test_burst_write_on_id_col_interleave_commit(self, cluster, vector, is_temp):
        self.base_burst_write_on_id_col_interleave_commit(cluster, vector, is_temp)
