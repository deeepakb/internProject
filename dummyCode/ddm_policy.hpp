/// Copyright 2022 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#pragma once

#include "ddm/ddm_lf_alp.hpp"
#include "xen_utils/smart_ptr.hpp"
#include "xen_utils/xen_except.h"

#include "pg/src/include/access/htup.h"
#include "pg/src/include/c.h"
#include "pg/src/include/catalog/pg_type.h"
#include "pg/src/include/nodes/nodes.h"
#include "pg/src/include/nodes/parsenodes.h"
#include "pg/src/include/nodes/pg_list.h"
#include "pg/src/include/optimizer/clauses.h"
#include "pg/src/include/postgres_ext.h"
#include "pg/src/include/utils/rel.h"
#include "pg/src/include/utils/syscache.h"

#include <memory>
#include <optional>
#include <set>
#include <string>
#include <tuple>
#include <unordered_map>
#include <unordered_set>
#include <utility>
#include <vector>

#include <string.h>

namespace ddm {

/// Create set to store type id for safe cast type match.
const std::unordered_set<Oid> kSafeTypeId{VARCHAROID, NUMERICOID, VARBYTEOID};

/// C++ struct representing a DDM Policy.
/// Design: https://tiny.amazon.com/18g73qsvb/quipECuoReds
struct Policy {
  /// OID of the Policy.
  Oid polid = 0;
  /// OID of the policy's resident DB.
  Oid poldbid = 0;
  /// Whether the mask will apply on ingest only.
  /// Currently unused.
  bool maskoningest = false;
  /// Name of the Masking policy.
  NameData polname = {};
  /// User who modified the policy last.
  int polmodifiedby = 0;
  /// Input attributes of the policy.
  std::string polattrs = "[]";
  /// Policy Expression SQL.
  std::string polexpr = "";
  /// Whether this policy was generated by seclog.
  bool is_seclog = false;

  /// Operator definitions to support std:: container types.  Comparison
  /// Ordering is in field definition order, but has no bearing on final logic.
  bool operator!=(const Policy& other) const { return !(operator==(other)); }
  bool operator==(const Policy& other) const {
    return polid == other.polid && poldbid == other.poldbid &&
           maskoningest == other.maskoningest &&
           strcmp(polname.data, other.polname.data) == 0 &&
           polmodifiedby == other.polmodifiedby && polattrs == other.polattrs &&
           polexpr == other.polexpr;
  }
  bool operator<(const Policy& other) const {
    if (polid != other.polid) {
      return polid < other.polid;
    }
    if (poldbid != other.poldbid) {
      return poldbid < other.poldbid;
    }
    if (maskoningest != other.maskoningest) {
      return maskoningest < other.maskoningest;
    }
    int polname_cmp = strcmp(polname.data, other.polname.data);
    if (polname_cmp == 0) {
      return polname_cmp;
    }
    if (polmodifiedby != other.polmodifiedby) {
      return polmodifiedby < other.polmodifiedby;
    }
    if (polattrs != other.polattrs) {
      return polattrs < other.polattrs;
    }
    return polexpr < other.polexpr;
  }
};

/// C++ struct representing a DDM Policy attachment to a relation.
/// Design: https://tiny.amazon.com/66gl6762/quipECuoReds
struct Attachment {
  /// OID of the policy ID for this attachment.
  Oid polid = 0;
  /// Permission id for attached masking policy.
  Oid permid = 0;
  /// Relation id for attached masking policy.
  Oid relid = 0;
  /// Policy application priority. Higher priority policies take precedence
  /// over lower priority policies when there are conflicting attachments.
  int4 polpriority = 0;
  /// Id of the user which executed the most recent attach masking policy.
  int4 polmodifiedby = 0;
  /// Input attributes for the masking policy expression in JSON.
  std::string polattrsin = "[]";
  /// Output attributes for the masking policy expression in JSON.
  std::string polattrsout = "[]";
  /// Optional linked Policy object. Can be null if the Attachment is
  /// retrieved independently of the policy.
  std::optional<Policy> pol = std::nullopt;

  /// Operator definitions to support std:: container types. Comparison
  /// Ordering is in field definition order, but has no bearing on final logic.
  bool operator<(const Attachment& other) const {
    if (polid != other.polid) {
      return polid < other.polid;
    }
    if (permid != other.permid) {
      return permid < other.permid;
    }
    if (relid != other.relid) {
      return relid < other.relid;
    }
    if (polpriority != other.polpriority) {
      return polpriority < other.polpriority;
    }
    if (polmodifiedby != other.polmodifiedby) {
      return polmodifiedby < other.polmodifiedby;
    }
    if (polattrsin != other.polattrsin) {
      return polattrsin < other.polattrsin;
    }
    if (polattrsout != other.polattrsout) {
      return polattrsout < other.polattrsout;
    }
    return pol < other.pol;
  }
};

/// @brief Container to hold the attached attribute in a form of an attribute
/// that describes the attachment column (attribute number, column name,
/// ColumnDef) and an optional SUPER path if the attachment is to a SUPER path.
struct AttachedAttribute {
  using Attribute = std::variant<int, std::string, std::shared_ptr<ColumnDef>>;

  Attribute attribute;
  std::optional<std::string> path;

  bool operator==(const AttachedAttribute& other) const {
    return attribute == other.attribute && path == other.path;
  }
};

/// @brief Container to hold the input / output columns' AttachedAttribute.
using attribute_info_t = std::vector<AttachedAttribute>;

/**
 * @brief C++ struct representing a DDM expression as it appears in the catalog.
 * The expression includes the SQL body of the expression (with alias) and the
 * type of the expression's output.
 *
 * @note The objects of this struct are meant to be serialized and put into DDM
 * catalog. If you need to change this struct definition, make sure that DDM
 * components that read it from, and write it to, JSON are aware.
 */
struct ParsedPolicyExpression {
  // SQL body of the expressions. For example: "masked_table"."a" + CAST(1 AS
  // INT4) .
  std::string expression;
  // OID of the type of the expression. For example above, OID is 23 (integer).
  Oid type_oid;
  // Mode of the type of the expression. For example above, mode is -1.
  int type_mode;

  bool operator!=(const ParsedPolicyExpression& other) const {
    return !(operator==(other));
  }

  bool operator==(const ParsedPolicyExpression& other) const {
    return expression == other.expression && type_oid == other.type_oid &&
           type_mode == other.type_mode;
  }
};

/// Internal struct used as context while mutating the parse tree.
struct SwapColDefMutatorCtx {
  struct Entry {
    std::string column_name;
    Oid policy_arg_typid;
    int32 policy_arg_typmod;
    std::optional<std::string> nested_path;
  };
  /// @example, entry { "a", { "b", VARCHAROID, 25, "\"nested\".\"path\"" }},
  /// would mean that inside the policy, all references to column
  /// MASK_PSEUDO_TBL."a" need to be replaced with "b"."nested"."path" of type
  /// VARCHAR(25). @note the nested path is guaranteed to be compatible with
  /// PathSet::ParsePathComponent and column type is currently used only for
  /// nested path (since they are always of ype SUPER).
  std::unordered_map<std::string, Entry> swap_map = {};
};

/// Internal struct representing a parsed DDM object.
struct ParsedPolicy {
  /// linked policy object.
  Policy pol;
  /// Parsed ColumnDef's of the input attributes.
  std::vector<std::shared_ptr<ColumnDef>> parsed_attrs = {};
  /// Parsed ResTargets of the policy.
  std::vector<std::shared_ptr<ResTarget>> parsed_pol = {};

  bool operator<(const ParsedPolicy& other) const {
    if (pol != other.pol) {
      return pol < other.pol;
    }
    if (parsed_attrs != other.parsed_attrs) {
      return parsed_attrs < other.parsed_attrs;
    }
    return parsed_pol < other.parsed_pol;
  }
};

/// Container for Parsed DDM Attachments.
struct ParsedPolicyAttachment {
  /// Linked unparsed Attachment
  Attachment attachment;
  /// Linked parsed DDM policy.
  ParsedPolicy pol;
  /// Parsed input attributes for the target relation.
  std::vector<AttachedAttribute> polattrs_in;
  /// Parsed output attributes for the target relation.
  std::vector<AttachedAttribute> polattrs_out;

  bool operator<(const ParsedPolicyAttachment& other) const {
    if (pol.pol != other.pol.pol) {
      return pol.pol < other.pol.pol;
    }
    return attachment < other.attachment;
  }
};

/// Internal Struct representing an entry in the map of colname -> masking
/// expression.
struct MergeEntry {
  /// shared_ptr to the ResTarget.
  std::shared_ptr<ResTarget> rtgt;
  /// Priority of this expression, higher priority policies take precedence.
  int4 priority = 0;
  /// shared_ptr to the Parsed Attachment which leads to this ResTarget. Can be
  /// NULL if the entry is for LF-ALP policy.
  std::shared_ptr<ParsedPolicyAttachment> attachment;
  // If the entry is for LF-ALP, will be set to the column name for the LF-ALP
  // policy.
  std::string lf_alp_column_name;
  // If this merge entry (i.e., mask) is for nested path, it is stored here
  // (compatible with RawPath).
  std::optional<std::string> nested_path;

  // Ability to sort entries by priority (we know there cannot be entries with
  // same priority for same column),
  bool operator<(const MergeEntry& other) const {
    if (priority != other.priority) return priority < other.priority;
    return nested_path < other.nested_path;
  }

  bool operator==(const MergeEntry& other) const {
    return (priority == other.priority) && (nested_path == other.nested_path);
  }
};

using NestedVarAttrs = std::unordered_set<AttrNumber>;
using NestedVarNames = std::unordered_set<std::string>;
using NestedVarMap = std::unordered_map<Oid, NestedVarNames>;
using MaskMap = std::unordered_map<std::string, std::vector<MergeEntry>>;
using MaskMapsCache = std::unordered_map<Oid, MaskMap>;

/// Convenience definition for map of relation to Parsed Policy.
using ParsedPolicies = std::unordered_map<Oid, ParsedPolicy>;

/// Convenience definition for map of relation to masking policies.
using RelQueries =
    std::unordered_map<Oid, std::optional<std::shared_ptr<Query>>>;
/// Convenience type definition for the parsed attachments of a given relation
/// OID.
using RelAttachments =
    std::unordered_map<Oid, std::set<ParsedPolicyAttachment>>;

/// Mutator context maintaining a cache of data to ensure visits to
/// policies, attachments, and rels are processed exactly once. Note, DDM nested
/// walker has it's own cache, so the max number of constructing mask maps is
/// two per query.
struct RewriteMutatorCtx {
  /// Cache of Attachments for each associated relation.
  RelAttachments attachments;
  /// Cache of built sub-queries for each associated relation.
  RelQueries queries;
  /// Cache of polid -> Parsed policy.
  ParsedPolicies policies;
  /// CmdType of the root query.
  CmdType cmd_type;
  /// Set of indexes of result relation / result relation alias taken from
  /// the top query (used for non-SELECT).
  std::unordered_set<Index> result_relation_indexes;
  /// Varno to set after mutating var.
  Index target_varno;
  /// Whether we need to rewrite the result refs. True for UPDATE/DELETE
  /// queries.
  bool rewrite_result_refs = false;
  /// Whether ddm has been applied to the query.
  bool ddm_applied = false;
  /// Top-level query (required to get external relations if needed).
  Query* top_query;
  /// For Lf-ALP, a map of relations to LF-ALP policies on all nested paths, as
  /// well as columns for the policy that are known to need object transform.
  ObjTransformAlpColumnsRelationMap obj_transform_alp_columns_rel_map;
  /// Stack of rtables so that any Var * can be tracked to its RTE from any
  /// subquery.
  std::vector<List*> rtables;
  /// The map (RTE OID -> Var Index) of variables for whom we will apply
  /// OBJECT_TRANSFORM as opposed to nested policies in-place.
  NestedVarMap obj_transform_vars;
  /// A cache of mask maps per RTE so that we don't recompute it and reload for
  /// each Var (instead, once per RTE).
  MaskMapsCache mask_maps_cache;
  /// Logs applied policy for the root query only once per execution.
  /// In extended protocol (jdbc) - prepare is always invoked prior to execute.
  /// This causes QueryRewriteAll to be invoked twice per request on the
  /// same query tree. Once during prepare, and once on execute. The results of
  /// the first rewrite are discarded in ReplanPreparedStatementImpl, then the
  /// original query tree is rewritten and executed. This flag is added to avoid
  /// the duplicate entry in log table.
  bool log_applied_policy = false;
};

/// Parses a Policy Reference and returns a ParsedPolicy
/// \param const Policy& pol
/// \return ParsedPolicy
ParsedPolicy ParsePolicy(const Policy& pol);

/// Parses a Attachment and returns a ParsedPolicyAttachment.
/// \param const Attachment& attachment
/// \return ParsedPolicyAttachment
ParsedPolicyAttachment ParseAttachment(
    const Attachment& attachment,
    std::optional<ParsedPolicy> policy = std::nullopt);

/// @brief Run PG analysis and transformation over the USING masking expressions
/// given the WITH column definitions.
///
/// Internally, the routine builds a query that is run through PG
/// transformations. If there are validation issues with the expressions (e.g.,
/// reference of a column that was not provided in WITH), a graceful error will
/// be thrown. The query structure is this:
///
/// SELECT
///  expression_1,
///  expression_2,
///  ...
///  expression_n
/// FROM (
///    SELECT
///      <<column_name>::<column_type>>,
///      ...
///      <<column_name>::<column_type>>
///    FROM <>
/// ) AS MASK_PSEUDO_TBL
///
/// Note that he inner subquery is constructed with a helper method.
///
/// @param column_definitions WITH clause of the DDM policy.
/// @param masking_expressions USING clause of the DDM policy.
/// @return std::pair<std::shared_ptr<Alias>,
/// std::vector<std::shared_ptr<Node>>> The alias that contains WITH clause
/// columns and the sequence of transformed expressions (transformed meaning all
/// references are resolved and validated).
std::tuple<std::shared_ptr<Alias>, std::vector<std::shared_ptr<Node>>,
           std::shared_ptr<List>>
AnalyzePolicyStatement(
    const std::vector<std::shared_ptr<ColumnDef>>& column_definitions,
    const std::vector<std::shared_ptr<Node>>& masking_expressions);

/// @brief Build a query that contains the masking expression referencing a
/// valid alias containing correct columns. This query only contains on
/// expression and will be used to convert to SQL so that the "deparsed"
/// expression can be extracted. The query structure is:
///
/// SELECT
///  expression AS DDM_DUMMY_NAME
/// FROM DDM_DUMMY_NAME.DDM_DUMMY_NAME
/// AS MASK_PSEUDO_TBL
///
/// Where DDM_DUMMY_NAME.DDM_DUMMY_NAME is modeled as an S3 external table to
/// make the query correct.
///
/// @param alias the alias containing USING clause columns
/// @param expression the transformed expression to deparse
/// @return std::shared_ptr<Query> the query object that can be run through Omni
/// to generate SQL
std::shared_ptr<Query> BuildQueryForDeparsing(std::shared_ptr<Alias> alias,
                                              std::shared_ptr<Node> expression);

/// @brief Builds a primitive SELECT subquery that includes the given column
/// definitions as targets. The structure is:
/// SELECT
///  <<column_name>::<column_type>>,
///  ...
///  <<column_name>::<column_type>>
/// FROM <>
///
/// The subquery->targetList is a list of targets (TargetEntry), where each
/// target is built from a result domain (Resdom), which is built from a column
/// definition (ColumnDef) provided as an argument to this function.
///
/// The FROM part of the query is not set, so it's not a valid query in itself.
/// It will only be used as component for later analysis.
///
/// @param column_definitions the columns with their types from the DDM policy
/// WITH clause.
/// @return std::pair<std::shared_ptr<Query>, std::shared_ptr<Alias>> a pair of
/// subquery itself as a Query* object, and the alias which contains the same
/// columns as the subquery.
std::pair<std::shared_ptr<Query>, std::shared_ptr<Alias>>
BuildSubqueryForAnalysis(
    const std::vector<std::shared_ptr<ColumnDef>>& column_definitions);

/// @brief Fetches DDM policy by the given ID, parses the policy expression,
/// walks over expression objects such as UDFs or lookup tables and verifies if
/// they have execute or select privilege granted to the masking policy.
/// @param polid Oid of the masking policy checked for permission.
void VerifyObjectPermissions(Oid polid);

/// Parses the DDM masking expression. Expects that the masking expression is
/// of the form ```2 * a, 5 + 5, 3 * masked_table.c```. Returns a vector
/// of shared_ptr's with attached PAlloc_deleter ResTarget pointers. The
/// masked_table prefix can be introduced during Create policy.
///
/// @param std::string expr masking expression
/// @return std::vector<shared_ptr<ResTarget>>
std::vector<std::shared_ptr<ResTarget>> ParsePolExpr(const std::string& expr);

/// Unset flag has_ddm_rewrite in the target range table entry of a DDM or RLS
/// sub-query (FGAC - fine grained access control). This is required to prevent
/// infinite recursive rewriting of DDM when parsing DDM as well as RLS
/// security policies.
///
/// @param query The RLS or DDM subquery to disable has_ddm_rewrite.
/// @param rte The RTE corresponding to the FGAC target relation.
void DisableDdmOnFgacTarget(Query* query, const RangeTblEntry* rte);

/// Merge parsed policy attachments for RTE. Returns a Query* with
/// internal reference to the original RTE.
/// @param ddm_obj_transform_vars the collection of variable for which to apply
/// OBJECT_TRANSFORM on RTE level.
/// @param obj_transform_alp_ctx obj_transform_alp_ctx for LF-ALP, object
/// transform context for the current RTE.
Query* MergePolsForRTE(const RangeTblEntry* rte, Query* top_query,
                       const std::set<ParsedPolicyAttachment>& attachments,
                       const NestedVarMap& ddm_obj_transform_vars,
                       const ObjTransformAlpColumnsCtx& obj_transform_alp_ctx);

/// Converts a set of set<ParsedPolicyAttachment> into a map of
/// col -> MergeEntry. Resulting ResTargets have the policy input columns
/// replaced with the target attachments.
/// \param set<ParsedPolicyAttachment> attachments
/// \param ObjTransformAlpColumnsCtx& obj_transform_alp_ctx for LF-ALP, object
/// transform context for the current RTE.
/// \return map<string,MergeEntry>
MaskMap BuildMaskMap(const std::set<ParsedPolicyAttachment>& attachments,
                     const ObjTransformAlpColumnsCtx& obj_transform_alp_ctx);

/// Provides a utility for walking a parse tree.  The walker currently supports
/// walking an Expr tree for all Expr's except certain sub-link expressions.
/// The walker will invoke the provided mutator function for each node in the
/// tree, prior to recursing into tree. Any mutator should then be implemented
/// as
///
/// Node* mutator_fn_t(Node*, void* context) {
///   if (node == NULL) return NULL;
///   if (IsA(node,MyTargetNodeType)) {/*my_code*/}
///   return node;
/// }
/// Notes:
/// - The node is provided as is to the mutator, mutators should appropriately
///   manage any required copies/frees.
/// - Implementation inspired by transformExpr which was unsuitable due to its
///   dependence on parse tree state.
Node* parse_tree_mutator(Node* node, mutator_fn_t mutator, void* context);

/// Mutation function used with parse_tree_mutator to replace
/// ColumnRef's with the attached col value rather than the policy col value.
Node* SwapColRefMutator(Node* node, void* context);

/// @param[in] pglist of Node* elements.
/// @return vector containing a deep copy of every node in the input.
/// @warning Do not use this function for sharing memory between processes.
template <typename T>
std::vector<std::shared_ptr<T>> deepcopy_list_to_vector(List* input) {
  std::vector<std::shared_ptr<T>> output;

  ListCell* lc = nullptr;
  T* ptr = nullptr;
  foreach(lc, input) {
    ptr = copyObject(reinterpret_cast<T*>(lfirst(lc)));
    std::shared_ptr<T> s_ptr(ptr, PAlloc_deleter());
    output.push_back(s_ptr);
  }
  return output;
}

/// Fetches a String from a toasted text type.
/// @example
///   std::string attrs_out =
///      FetchStringFromText(PERMISSIONMASKRELPRIORITY, attachment_tuple,
///                          Anum_pg_permission_mask_polattrsout, true);
/// @param[in] SysCacheIdentifier cache - The cache to fetch the toasted
/// attribute from.
/// @param[in] HeapTuple tup - Tuple to fetch toasted attribute for.
/// @param[in] int attnum - Column Number to fetch the attribute for.
/// @param[in] bool fail_on_null - Whether to XCHECK on missing toasted
/// attribute.
/// @return std:string - toasted string..
std::string FetchStringFromText(SysCacheIdentifier cache, HeapTuple tup,
                                int attnum, bool fail_on_null);

/// Builds an Attachment from the provided pg_permission_mask HeapTuple.
/// @param[in] attachment_tuple - Immutable_pg_permission_mask mask tuple.
/// @return - Attachment - Attachment representing the pg_permission_mask.
Attachment AttachmentFromTuple(HeapTuple attachment_tuple);

/// Builds an Attachment from the provided Immutable_pg_policy_mask HeapTuple.
/// @param[in] pol_tuple - Immutable_pg_policy_mask tuple.
/// @return - Policy - Policy representing the pg_policy_mask.
Policy PolicyFromTuple(HeapTuple pol_tuple);

/// Fetches a policy by polid.
/// @param[in] Oid polid - policy id to fetch.
/// @throws ereport - if the policy ID cannot be found.
Policy FetchPolicy(Oid polid);

/// Fetch attachments for a relation, accepts an optional AclID to filter
/// attachments for a given UserId or RoleID. If both RoleID and UserID are
/// provided a PGCHECK is thrown.
/// @param[in] Oid relid - relid to find attachments for.
/// @param[in] optional<AclId> userid - User to filter attachments by.
/// @param[in] optional<AclId> roleid - Role to filter attachments by.
/// @returns - Set of Attachments for the given relid/user_id
/// @throws - elog Error if an invalid tuple is found.
/// @note Only one of userid and roleid can be specified.
std::set<Attachment> FetchAttachmentsForRel(const Oid relid,
                                            const std::optional<AclId> userid,
                                            const std::optional<AclId> roleid);

/// Test that there is at least one valid attachment for this relation.
/// @param[in] Oid relid - relid to test
/// @returns - True if attachments exist
/// @throws - elog on invalid catalog entries.
bool HasAttachmentsForRel(const Oid relid);

/**
 * @brief Tests whether there exist attachments for the given policy.
 *
 * This function reads all attachments from the pg_permission_mask and filters
 * by the policy OID.
 */
bool HasAttachmentsForPolicy(const Oid policy_oid);

/// @brief Converts a sequence of column names (given as string Value's) into a
/// corresponding sequence of attribute numbers.
///
/// @warning this function is defined and tested only for relation types table
/// and regular view. For LBV this functionality does not make sense (function
/// will ereport), and for MV it was not tested.
///
/// The column names are matched with the relation specified by rel_id and the
/// attribute numbers loaded from pg_attribute.
///
/// @param rel_id Oid of the relation to which the column belongs.
/// @param column_names sequence of column names.
/// @return std::vector<int> the sequence of corresponding attribute numbers.
std::vector<int> ColumnNamesToAttributeNumbers(
    Oid rel_id, const std::vector<std::shared_ptr<Value>>& column_names);

/// @brief Constructs a vector of ColumnDef shared pointers from attributes
/// (represented as attribute numbers) and a relation.
///
/// @warning this function is defined and tested only for relation types table
/// and regular view. For LBV this functionality does not make sense (function
/// will fail an XPGCHECK), and for MV it was not tested. Note that the function
/// expects (and XPHCHECKs) that the type of attachment is int.
///
/// The attribute numbers are matched with the specified relation type OIDs and
/// typmods are loaded from pg_attribute. The paths are carried over.
///
/// @param relation Relation which the attributes should be resolved in.
/// @param attributes the sequence of attributes (numbers are used, paths are
/// carried over).
/// @return a vector of attached attributes, where attribute type is palloc'd
/// shared_ptr ColumnDefs.
std::vector<AttachedAttribute> AttributesToColumnDefs(
    const Relation& relation, const std::vector<AttachedAttribute>& attributes);

/// @brief Matches the typid and typmod of the input type_name with the given
/// typid and typmod checking safe cast and strict cast.
/// Allowed data types for safe cast - VARCHAR, NUMERIC, VARBYTE.
/// Strict cast requires that typid and typmod are exactly equal.
/// @param type_name typename for the data type in the policy.
/// @param typid typeid for the data type in the table column.
/// @param typmod typemod is the limit for the data type in the table column.
/// @return returns true if castable for either safe cast or strict cast,
/// otherwise false.
bool IsCastable(TypeName* type_name, Oid typid, int32 typmod);

/// @brief Checks if the given typid is cast compatible with a SUPER path.
/// A SUPER path is cast compatible with SUPER, STRING, NUMERIC and BOOLEAN
/// types.
/// @return returns true if cast compatible.
bool IsSuperNestedCastable(Oid typid);

/// @brief Parse analyzes the rte to get the columns information, create
/// columndefs for the parsed columns and insert the columndefs in the given
/// columndefs map. This function is useful when the relation type is LBV as for
/// LBV we do not have the columns information during attach time.
/// @param rte RangeTblEntry for which to get the column information.
/// @param[out] parsed_lbv_columndefs map where Columndefs created from the
/// parsed columns are inserted.
/// @return std::vector of std::string containing the columns names of the
/// parsed columns for the given rte.
std::vector<std::string> ParseLbvColumns(
    const RangeTblEntry* rte,
    std::unordered_map<std::string, std::shared_ptr<ColumnDef>>&
        parsed_lbv_columndefs);

/// @brief Checks the type compatibility of each of the input columns and output
/// columns of a parsed attachment with the columndef entry in the input
/// columndefs_map that has the same column name. If for some parsed attachment
/// column name no columndef entry is found in the columndefs_map, outputs
/// ereport ERROR. If any column of the parsed attachment is not type compatible
/// with the matched entry in the columndefs_map, outputs error. This function
/// is useful when the relation type is LBV. For LBVs we cannot perform type
/// compatibility checks during policy attach time as pg_attribute does not
/// store LBV columns information.
/// @param attachment The ParsedPolicyAttachment which input and output columns
/// are checked for type compatibility.
/// @param parsed_lbv_columndefs Map containing the columndefs against which
/// attachment is checked.
/// @param rel_name The name of the relation to check for type compatibility.
/// rel_name is used for error reporting when type compatibility fails.
void CheckAttachmentForColumnsType(
    ParsedPolicyAttachment& attachment,
    std::unordered_map<std::string, std::shared_ptr<ColumnDef>> const&
        columndefs_map,
    const char* rel_name);

/// @brief Converts a list of column names (each list entry is a list of column
/// components) into a corresponding vector of AttachedAttributes.
///
/// @param rel_id Oid of the relation to which the columns belong.
/// @param colnames List of column names. Each list entry contains a list of
/// column components (column name and optional path components).
/// @return a std::pair of attribute_info_t and bool that contains
/// attribute_info_t(vector of AttachedAttribute from the given Columns) and
/// true if any of the input columns has a SUPER path.
std::pair<attribute_info_t, bool> ColumnNamesToAttachedAttributes(
    Oid rel_id, List* colnames);

/// @brief Converts a list of a column's components (column name and optional
/// path components) to an AttachedAttribute.
///
/// AttachedAttribute.attribute can be int (for relkind of regular table / view)
/// or std::string (for relkind of LBV). with the input rel_id, relkind is
/// determined. If the relkind is regular table / view, the column names are
/// matched with the relation specified by rel_id and the attribute numbers
/// loaded from pg_attribute. For relkind of LBV, such attach time check is not
/// possible and should have this check during query time.
///
/// @param column_components List of column components.
/// @param rel_id Oid of the relation that the given column belongs to.
/// @param has_path [out] sets to true if column components include any path
/// components.
/// @return An AttachedAttribute from the column components.
ddm::AttachedAttribute ColumnComponentsToAttachedAttribute(
    List* column_components, Oid rel_id, bool* has_path);

/// @brief appends the given path component to the input std::stringstream of
/// path.
///
/// @param ss_path [Out] the std::stringstream where the path_component is
/// added.
/// @param path_component the path component to append.
void AddComponentToPath(std::stringstream& ss_path, std::string path_component);

/// Returns a target name to put after FROM keyword for the RTE SELECT query.
/// Different logic for LF-managed RTE and local RTE.
std::string GetRTEQueryTargetName(const RangeTblEntry* rte);

}  // namespace ddm
