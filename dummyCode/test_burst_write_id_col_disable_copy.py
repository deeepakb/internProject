# Copyright 2022 Amazon.com, Inc. or its affiliates
# All Rights Reserved
import logging
import pytest

from raff.burst.burst_write import BurstWriteTest
from raff.burst.burst_super_simulated_mode_helper import super_simulated_mode
from raff.common.db.session import DbSession
from raff.burst.burst_write import burst_write_basic_gucs
from raff.burst.burst_test import setup_teardown_burst

log = logging.getLogger(__name__)
__all__ = [super_simulated_mode, setup_teardown_burst]


class BWIdColDisableCopy(BurstWriteTest):
    def _execute_one_col_copy(self, cursor, burst_tbl, file_idx):
        s3_path = 's3://burst-write-id-col-test/bw_id_col_1_col_{}.csv.gz'
        try:
            cursor.run_copy(
                burst_tbl + "(c0)", s3_path.format(file_idx), gzip=True)
        except Exception as e:
            log.info("COPY exception {}".format(str(e)))

    def _execute_two_col_copy(self, cursor, burst_tbl, file_idx):
        s3_path = 's3://burst-write-id-col-test/bw_id_col_2_col_{}.csv.gz'
        try:
            cursor.run_copy(
                burst_tbl + "(c0,c2)",
                s3_path.format(file_idx),
                gzip=True,
                delimiter=",")
        except Exception as e:
            log.info("COPY exception {}".format(str(e)))

    def base_test_burst_write_id_col_disable_copy(self, cluster):
        """
        This test is to make sure the burst copy on tables with id col cannot
        burst when GUC is turned off.
        """
        db_session = DbSession(cluster.get_conn_params(user='master'))
        tbl_name = "dp35939_tbl"
        with db_session.cursor() as cursor:
            cursor.execute("set query_group to burst;")
            tbl_def = (
                "create table dp35939_tbl(c0 int, c1 bigint identity(0, 1),"
                "c2 BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL) "
                "diststyle even;")
            cursor.execute(tbl_def)
            burst_error_code = 68
            # test disble burst copy
            self._start_and_wait_for_refresh(cluster)
            self._execute_one_col_copy(cursor, tbl_name, 0)
            self.check_last_copy_not_bursted_status(cluster, cursor,
                                                    burst_error_code)
            self._start_and_wait_for_refresh(cluster)
            self._execute_two_col_copy(cursor, tbl_name, 0)
            self.check_last_copy_not_bursted_status(cluster, cursor,
                                                    burst_error_code)


@pytest.mark.serial_only
@pytest.mark.localhost_only
@pytest.mark.skip_load_data
@pytest.mark.super_simulated_mode
@pytest.mark.usefixtures("super_simulated_mode")
@pytest.mark.custom_burst_gucs(
    gucs={
        'slices_per_node': '3',
        'burst_enable_write': 'true',
        'burst_enable_write_id_col': 'true',
    })
@pytest.mark.custom_local_gucs(gucs={
    'burst_enable_write_id_col': 'true',
})
class TestBurstWriteIdColDisableCopySS(BWIdColDisableCopy):
    def test_burst_write_id_cols_disable_copy_ss(self, cluster):
        self.base_test_burst_write_id_col_disable_copy(cluster)


@pytest.mark.serial_only
@pytest.mark.cluster_only
@pytest.mark.custom_burst_gucs(
    gucs=dict(list(burst_write_basic_gucs.items()) + [(
        'burst_enable_write', 'true'), ('burst_enable_write_id_col', 'true')]))
@pytest.mark.custom_local_gucs(gucs={
    'burst_enable_write_id_col': 'true',
    'burst_enable_copy_id_col': 'false'
})
@pytest.mark.usefixtures("setup_teardown_burst")
class TestBurstWriteIdColDisableCopyCluster(BWIdColDisableCopy):
    def test_burst_write_id_cols_disable_copy_cluster(self, cluster):
        self.base_test_burst_write_id_col_disable_copy(cluster)
